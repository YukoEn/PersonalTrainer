{"ast":null,"code":"import _classCallCheck from \"/Users/yukoenqvist/personaltrainer/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport PropTypes from 'prop-types';\nimport invariant from 'invariant';\nvar localePropType = PropTypes.oneOfType([PropTypes.string, PropTypes.func]);\n\nfunction _format(localizer, formatter, value, format, culture) {\n  var result = typeof format === 'function' ? format(value, culture, localizer) : formatter.call(localizer, value, format, culture);\n  invariant(result == null || typeof result === 'string', '`localizer format(..)` must return a string, null, or undefined');\n  return result;\n}\n\nvar DateLocalizer = function DateLocalizer(spec) {\n  var _this = this;\n\n  _classCallCheck(this, DateLocalizer);\n\n  invariant(typeof spec.format === 'function', 'date localizer `format(..)` must be a function');\n  invariant(typeof spec.parse === 'function', 'date localizer `parse(..)` must be a function');\n  invariant(typeof spec.firstOfWeek === 'function', 'date localizer `firstOfWeek(..)` must be a function');\n  this.propType = spec.propType || localePropType;\n  this.formats = spec.formats;\n  this.startOfWeek = spec.firstOfWeek;\n\n  this.format = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _format.apply(void 0, [_this, spec.format].concat(args));\n  };\n\n  this.parse = function (value, format, culture) {\n    var result = spec.parse.call(_this, value, format, culture);\n    invariant(result == null || result instanceof Date && !isNaN(result.getTime()), 'date localizer `parse(..)` must return a valid Date, null, or undefined');\n    return result;\n  };\n};\n\nvar localizer = {\n  parse: error,\n  format: error,\n  startOfWeek: error\n};\nexport function set(newLocalizer) {\n  if (!newLocalizer.__isLocalizer__) {\n    newLocalizer = new DateLocalizer(newLocalizer);\n    newLocalizer.__isLocalizer__ = true;\n  }\n\n  localizer = newLocalizer;\n  return localizer;\n}\nvar exp = {\n  parse: function parse() {\n    var _localizer;\n\n    return (_localizer = localizer).parse.apply(_localizer, arguments);\n  },\n  format: function format() {\n    var _localizer2;\n\n    return (_localizer2 = localizer).format.apply(_localizer2, arguments);\n  },\n  startOfWeek: function startOfWeek() {\n    var _localizer3;\n\n    return (_localizer3 = localizer).startOfWeek.apply(_localizer3, arguments);\n  }\n};\nexport default exp;\n\nfunction error() {\n  throw new Error('You have not selected a localization strategy for Big Calendar. ' + 'Please use either of the two included.');\n}","map":{"version":3,"sources":["/Users/yukoenqvist/personaltrainer/src/localizer.js"],"names":["PropTypes","invariant","localePropType","oneOfType","string","func","_format","localizer","formatter","value","format","culture","result","call","DateLocalizer","spec","parse","firstOfWeek","propType","formats","startOfWeek","args","Date","isNaN","getTime","error","set","newLocalizer","__isLocalizer__","exp","Error"],"mappings":"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","sourcesContent":["import PropTypes from 'prop-types';\nimport invariant from 'invariant';\n\nconst localePropType = PropTypes.oneOfType([\n        PropTypes.string,\n        PropTypes.func\n      ]);\n\nfunction _format(localizer, formatter, value, format, culture) {\n  let result = typeof format === 'function'\n    ? format(value, culture, localizer)\n    : formatter.call(localizer, value, format, culture)\n\n  invariant(result == null || typeof result === 'string'\n    , '`localizer format(..)` must return a string, null, or undefined')\n\n  return result\n}\n\nclass DateLocalizer {\n\n  constructor(spec) {\n    invariant(typeof spec.format === 'function'\n      , 'date localizer `format(..)` must be a function')\n    invariant(typeof spec.parse === 'function'\n      , 'date localizer `parse(..)` must be a function')\n    invariant(typeof spec.firstOfWeek === 'function'\n      , 'date localizer `firstOfWeek(..)` must be a function')\n\n    this.propType = spec.propType || localePropType\n\n    this.formats = spec.formats\n    this.startOfWeek = spec.firstOfWeek\n\n    this.format = (...args) => _format(this, spec.format, ...args)\n\n    this.parse = (value, format, culture) => {\n      let result = spec.parse.call(this, value, format, culture)\n\n      invariant(result == null\n        || (result instanceof Date && !isNaN(result.getTime()))\n        , 'date localizer `parse(..)` must return a valid Date, null, or undefined')\n\n      return result\n    }\n  }\n}\n\nlet localizer = {\n  parse: error,\n  format:error,\n  startOfWeek: error\n}\n\nexport function set(newLocalizer) {\n  if (!newLocalizer.__isLocalizer__) {\n    newLocalizer = new DateLocalizer(newLocalizer);\n    newLocalizer.__isLocalizer__ = true\n  }\n\n  localizer = newLocalizer;\n  return localizer;\n}\n\nlet exp = {\n  parse(...args){\n    return localizer.parse(...args)\n  },\n\n  format(...args){\n    return localizer.format(...args)\n  },\n\n  startOfWeek(...args){\n    return localizer.startOfWeek(...args)\n  }\n}\n\nexport default exp\n\nfunction error(){\n  throw new Error(\n    'You have not selected a localization strategy for Big Calendar. ' +\n    'Please use either of the two included.')\n}\n"]},"metadata":{},"sourceType":"module"}