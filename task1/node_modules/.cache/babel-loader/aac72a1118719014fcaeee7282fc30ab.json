{"ast":null,"code":"export function isSelected(event, selected) {\n  if (!event || selected == null) return false;\n  return [].concat(selected).indexOf(event) !== -1;\n}\nexport function slotWidth(rowBox, slots) {\n  var rowWidth = rowBox.right - rowBox.left;\n  var cellWidth = rowWidth / slots;\n  return cellWidth;\n}\nexport function getCellAtX(rowBox, x, cellWidth, rtl, slots) {\n  return rtl ? slots - 1 - Math.floor((x - rowBox.left) / cellWidth) : Math.floor((x - rowBox.left) / cellWidth);\n}\nexport function pointInBox(box, _ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  return y >= box.top && y <= box.bottom && x >= box.left && x <= box.right;\n}\nexport function dateCellSelection(start, rowBox, box, slots, rtl) {\n  var startIdx = -1;\n  var endIdx = -1;\n  var lastSlotIdx = slots - 1;\n  var cellWidth = slotWidth(rowBox, slots); // cell under the mouse\n\n  var currentSlot = getCellAtX(rowBox, box.x, cellWidth, rtl, slots); // Identify row as either the initial row\n  // or the row under the current mouse point\n\n  var isCurrentRow = rowBox.top < box.y && rowBox.bottom > box.y;\n  var isStartRow = rowBox.top < start.y && rowBox.bottom > start.y; // this row's position relative to the start point\n\n  var isAboveStart = start.y > rowBox.bottom;\n  var isBelowStart = rowBox.top > start.y;\n  var isBetween = box.top < rowBox.top && box.bottom > rowBox.bottom; // this row is between the current and start rows, so entirely selected\n\n  if (isBetween) {\n    startIdx = 0;\n    endIdx = lastSlotIdx;\n  }\n\n  if (isCurrentRow) {\n    if (isBelowStart) {\n      startIdx = 0;\n      endIdx = currentSlot;\n    } else if (isAboveStart) {\n      startIdx = currentSlot;\n      endIdx = lastSlotIdx;\n    }\n  }\n\n  if (isStartRow) {\n    // select the cell under the initial point\n    startIdx = endIdx = rtl ? lastSlotIdx - Math.floor((start.x - rowBox.left) / cellWidth) : Math.floor((start.x - rowBox.left) / cellWidth);\n\n    if (isCurrentRow) {\n      if (currentSlot < startIdx) startIdx = currentSlot;else endIdx = currentSlot; //select current range\n    } // the current row is below start row\n    else if (start.y < box.y) {\n        // select cells to the right of the start cell\n        endIdx = lastSlotIdx;\n      } else {\n        // select cells to the left of the start cell\n        startIdx = 0;\n      }\n  }\n\n  return {\n    startIdx: startIdx,\n    endIdx: endIdx\n  };\n}","map":{"version":3,"sources":["/Users/yukoenqvist/personaltrainer/src/utils/selection.js"],"names":["isSelected","event","selected","concat","indexOf","slotWidth","rowBox","slots","rowWidth","right","left","cellWidth","getCellAtX","x","rtl","Math","floor","pointInBox","box","y","top","bottom","dateCellSelection","start","startIdx","endIdx","lastSlotIdx","currentSlot","isCurrentRow","isStartRow","isAboveStart","isBelowStart","isBetween"],"mappings":"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","sourcesContent":["\nexport function isSelected(event, selected){\n  if (!event || selected == null) return false;\n  return [].concat(selected).indexOf(event) !== -1\n}\n\nexport function slotWidth(rowBox, slots){\n  let rowWidth = rowBox.right - rowBox.left;\n  let cellWidth = rowWidth / slots\n\n  return cellWidth\n}\n\nexport function getCellAtX(rowBox, x, cellWidth, rtl, slots) {\n   return (rtl ? slots - 1 - Math.floor((x - rowBox.left) / cellWidth) :\n                 Math.floor((x - rowBox.left) / cellWidth));\n}\n\nexport function pointInBox(box, { x, y }) {\n   return (\n      (y >= box.top && y <= box.bottom) &&\n      (x >= box.left && x <= box.right)\n   )\n}\n\nexport function dateCellSelection(start, rowBox, box, slots, rtl){\n  let startIdx = -1;\n  let endIdx = -1;\n  let lastSlotIdx = slots - 1\n\n  let cellWidth = slotWidth(rowBox, slots);\n\n  // cell under the mouse\n  let currentSlot = getCellAtX(rowBox, box.x, cellWidth, rtl, slots);\n\n  // Identify row as either the initial row\n  // or the row under the current mouse point\n  let isCurrentRow = rowBox.top < box.y && rowBox.bottom > box.y\n  let isStartRow = rowBox.top < start.y && rowBox.bottom > start.y\n\n  // this row's position relative to the start point\n  let isAboveStart = start.y > rowBox.bottom;\n  let isBelowStart = rowBox.top > start.y\n  let isBetween = box.top < rowBox.top && box.bottom > rowBox.bottom\n\n  // this row is between the current and start rows, so entirely selected\n  if (isBetween) {\n    startIdx = 0\n    endIdx = lastSlotIdx\n  }\n\n  if (isCurrentRow) {\n    if (isBelowStart) {\n      startIdx = 0\n      endIdx = currentSlot;\n    }\n    else if (isAboveStart) {\n      startIdx = currentSlot\n      endIdx = lastSlotIdx;\n    }\n  }\n\n  if (isStartRow) {\n    // select the cell under the initial point\n    startIdx = endIdx = ( rtl ? lastSlotIdx - Math.floor((start.x - rowBox.left) / cellWidth) :\n                                Math.floor((start.x - rowBox.left) / cellWidth));\n\n    if (isCurrentRow) {\n      if (currentSlot < startIdx) startIdx = currentSlot\n      else endIdx = currentSlot; //select current range\n    }\n    // the current row is below start row\n    else if (start.y < box.y) {\n      // select cells to the right of the start cell\n      endIdx = lastSlotIdx\n    }\n    else {\n      // select cells to the left of the start cell\n      startIdx = 0\n    }\n  }\n\n  return { startIdx, endIdx }\n}\n"]},"metadata":{},"sourceType":"module"}