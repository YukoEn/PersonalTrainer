{"ast":null,"code":"import _classCallCheck from \"/Users/yukoenqvist/personaltrainer/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/yukoenqvist/personaltrainer/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport contains from 'dom-helpers/query/contains';\nimport closest from 'dom-helpers/query/closest';\nimport events from 'dom-helpers/events';\n\nfunction addEventListener(type, handler) {\n  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;\n  events.on(target, type, handler);\n  return {\n    remove: function remove() {\n      events.off(target, type, handler);\n    }\n  };\n}\n\nfunction isOverContainer(container, x, y) {\n  return !container || contains(container, document.elementFromPoint(x, y));\n}\n\nexport function isEvent(node, _ref) {\n  var clientX = _ref.clientX,\n      clientY = _ref.clientY;\n  var target = document.elementFromPoint(clientX, clientY);\n  return !!closest(target, '.rbc-event', node);\n}\n\nfunction getEventCoordinates(e) {\n  var target = e;\n\n  if (e.touches && e.touches.length) {\n    target = e.touches[0];\n  }\n\n  return {\n    clientX: target.clientX,\n    clientY: target.clientY,\n    pageX: target.pageX,\n    pageY: target.pageY\n  };\n}\n\nvar clickTolerance = 5;\nvar clickInterval = 250;\n\nvar Selection =\n/*#__PURE__*/\nfunction () {\n  function Selection(node) {\n    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref2$global = _ref2.global,\n        global = _ref2$global === void 0 ? false : _ref2$global,\n        _ref2$longPressThresh = _ref2.longPressThreshold,\n        longPressThreshold = _ref2$longPressThresh === void 0 ? 250 : _ref2$longPressThresh;\n\n    _classCallCheck(this, Selection);\n\n    this.container = node;\n    this.globalMouse = !node || global;\n    this.longPressThreshold = longPressThreshold;\n    this._listeners = Object.create(null);\n    this._handleInitialEvent = this._handleInitialEvent.bind(this);\n    this._handleMoveEvent = this._handleMoveEvent.bind(this);\n    this._handleTerminatingEvent = this._handleTerminatingEvent.bind(this);\n    this._keyListener = this._keyListener.bind(this); // Fixes an iOS 10 bug where scrolling could not be prevented on the window.\n    // https://github.com/metafizzy/flickity/issues/457#issuecomment-254501356\n\n    this._onTouchMoveWindowListener = addEventListener('touchmove', function () {}, window);\n    this._onKeyDownListener = addEventListener('keydown', this._keyListener);\n    this._onKeyUpListener = addEventListener('keyup', this._keyListener);\n\n    this._addInitialEventListener();\n  }\n\n  _createClass(Selection, [{\n    key: \"on\",\n    value: function on(type, handler) {\n      var handlers = this._listeners[type] || (this._listeners[type] = []);\n      handlers.push(handler);\n      return {\n        remove: function remove() {\n          var idx = handlers.indexOf(handler);\n          if (idx !== -1) handlers.splice(idx, 1);\n        }\n      };\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(type) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var result;\n      var handlers = this._listeners[type] || [];\n      handlers.forEach(function (fn) {\n        if (result === undefined) result = fn.apply(void 0, args);\n      });\n      return result;\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      this.listeners = Object.create(null);\n      this._onTouchMoveWindowListener && this._onTouchMoveWindowListener.remove();\n      this._onInitialEventListener && this._onInitialEventListener.remove();\n      this._onEndListener && this._onEndListener.remove();\n      this._onMoveListener && this._onMoveListener.remove();\n      this._onKeyUpListener && this._onKeyUpListener.remove();\n      this._onKeyDownListener && this._onKeyDownListener.remove();\n    }\n  }, {\n    key: \"isSelected\",\n    value: function isSelected(node) {\n      var box = this._selectRect;\n      if (!box || !this.selecting) return false;\n      return objectsCollide(box, getBoundsForNode(node));\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(items) {\n      var box = this._selectRect; //not selecting\n\n      if (!box || !this.selecting) return [];\n      return items.filter(this.isSelected, this);\n    } // Adds a listener that will call the handler only after the user has pressed on the screen\n    // without moving their finger for 250ms.\n\n  }, {\n    key: \"_addLongPressListener\",\n    value: function _addLongPressListener(handler, initialEvent) {\n      var _this = this;\n\n      var timer = null;\n      var touchMoveListener = null;\n      var touchEndListener = null;\n\n      var handleTouchStart = function handleTouchStart(initialEvent) {\n        timer = setTimeout(function () {\n          cleanup();\n          handler(initialEvent);\n        }, _this.longPressThreshold);\n        touchMoveListener = addEventListener('touchmove', function () {\n          return cleanup();\n        });\n        touchEndListener = addEventListener('touchend', function () {\n          return cleanup();\n        });\n      };\n\n      var touchStartListener = addEventListener('touchstart', handleTouchStart);\n\n      var cleanup = function cleanup() {\n        if (timer) {\n          clearTimeout(timer);\n        }\n\n        if (touchMoveListener) {\n          touchMoveListener.remove();\n        }\n\n        if (touchEndListener) {\n          touchEndListener.remove();\n        }\n\n        timer = null;\n        touchMoveListener = null;\n        touchEndListener = null;\n      };\n\n      if (initialEvent) {\n        handleTouchStart(initialEvent);\n      }\n\n      return {\n        remove: function remove() {\n          cleanup();\n          touchStartListener.remove();\n        }\n      };\n    } // Listen for mousedown and touchstart events. When one is received, disable the other and setup\n    // future event handling based on the type of event.\n\n  }, {\n    key: \"_addInitialEventListener\",\n    value: function _addInitialEventListener() {\n      var _this2 = this;\n\n      var mouseDownListener = addEventListener('mousedown', function (e) {\n        _this2._onInitialEventListener.remove();\n\n        _this2._handleInitialEvent(e);\n\n        _this2._onInitialEventListener = addEventListener('mousedown', _this2._handleInitialEvent);\n      });\n      var touchStartListener = addEventListener('touchstart', function (e) {\n        _this2._onInitialEventListener.remove();\n\n        _this2._onInitialEventListener = _this2._addLongPressListener(_this2._handleInitialEvent, e);\n      });\n      this._onInitialEventListener = {\n        remove: function remove() {\n          mouseDownListener.remove();\n          touchStartListener.remove();\n        }\n      };\n    }\n  }, {\n    key: \"_handleInitialEvent\",\n    value: function _handleInitialEvent(e) {\n      var _getEventCoordinates = getEventCoordinates(e),\n          clientX = _getEventCoordinates.clientX,\n          clientY = _getEventCoordinates.clientY,\n          pageX = _getEventCoordinates.pageX,\n          pageY = _getEventCoordinates.pageY;\n\n      var node = this.container(),\n          collides,\n          offsetData; // Right clicks\n\n      if (e.which === 3 || e.button === 2 || !isOverContainer(node, clientX, clientY)) return;\n\n      if (!this.globalMouse && node && !contains(node, e.target)) {\n        var _normalizeDistance = normalizeDistance(0),\n            top = _normalizeDistance.top,\n            left = _normalizeDistance.left,\n            bottom = _normalizeDistance.bottom,\n            right = _normalizeDistance.right;\n\n        offsetData = getBoundsForNode(node);\n        collides = objectsCollide({\n          top: offsetData.top - top,\n          left: offsetData.left - left,\n          bottom: offsetData.bottom + bottom,\n          right: offsetData.right + right\n        }, {\n          top: pageY,\n          left: pageX\n        });\n        if (!collides) return;\n      }\n\n      var result = this.emit('beforeSelect', this._initialEventData = {\n        isTouch: /^touch/.test(e.type),\n        x: pageX,\n        y: pageY,\n        clientX: clientX,\n        clientY: clientY\n      });\n      if (result === false) return;\n\n      switch (e.type) {\n        case 'mousedown':\n          this._onEndListener = addEventListener('mouseup', this._handleTerminatingEvent);\n          this._onMoveListener = addEventListener('mousemove', this._handleMoveEvent);\n          break;\n\n        case 'touchstart':\n          this._handleMoveEvent(e);\n\n          this._onEndListener = addEventListener('touchend', this._handleTerminatingEvent);\n          this._onMoveListener = addEventListener('touchmove', this._handleMoveEvent);\n          break;\n\n        default:\n          break;\n      }\n    }\n  }, {\n    key: \"_handleTerminatingEvent\",\n    value: function _handleTerminatingEvent(e) {\n      var _getEventCoordinates2 = getEventCoordinates(e),\n          pageX = _getEventCoordinates2.pageX,\n          pageY = _getEventCoordinates2.pageY;\n\n      this.selecting = false;\n      this._onEndListener && this._onEndListener.remove();\n      this._onMoveListener && this._onMoveListener.remove();\n      if (!this._initialEventData) return;\n      var inRoot = !this.container || contains(this.container(), e.target);\n      var bounds = this._selectRect;\n      var click = this.isClick(pageX, pageY);\n      this._initialEventData = null;\n\n      if (click && !inRoot) {\n        return this.emit('reset');\n      }\n\n      if (click && inRoot) {\n        return this._handleClickEvent(e);\n      } // User drag-clicked in the Selectable area\n\n\n      if (!click) return this.emit('select', bounds);\n    }\n  }, {\n    key: \"_handleClickEvent\",\n    value: function _handleClickEvent(e) {\n      var _getEventCoordinates3 = getEventCoordinates(e),\n          pageX = _getEventCoordinates3.pageX,\n          pageY = _getEventCoordinates3.pageY,\n          clientX = _getEventCoordinates3.clientX,\n          clientY = _getEventCoordinates3.clientY;\n\n      var now = new Date().getTime();\n\n      if (this._lastClickData && now - this._lastClickData.timestamp < clickInterval) {\n        // Double click event\n        this._lastClickData = null;\n        return this.emit('doubleClick', {\n          x: pageX,\n          y: pageY,\n          clientX: clientX,\n          clientY: clientY\n        });\n      } // Click event\n\n\n      this._lastClickData = {\n        timestamp: now\n      };\n      return this.emit('click', {\n        x: pageX,\n        y: pageY,\n        clientX: clientX,\n        clientY: clientY\n      });\n    }\n  }, {\n    key: \"_handleMoveEvent\",\n    value: function _handleMoveEvent(e) {\n      var _this$_initialEventDa = this._initialEventData,\n          x = _this$_initialEventDa.x,\n          y = _this$_initialEventDa.y;\n\n      var _getEventCoordinates4 = getEventCoordinates(e),\n          pageX = _getEventCoordinates4.pageX,\n          pageY = _getEventCoordinates4.pageY;\n\n      var w = Math.abs(x - pageX);\n      var h = Math.abs(y - pageY);\n      var left = Math.min(pageX, x),\n          top = Math.min(pageY, y),\n          old = this.selecting;\n      this.selecting = true;\n      this._selectRect = {\n        top: top,\n        left: left,\n        x: pageX,\n        y: pageY,\n        right: left + w,\n        bottom: top + h\n      };\n\n      if (!old) {\n        this.emit('selectStart', this._initialEventData);\n      }\n\n      if (!this.isClick(pageX, pageY)) this.emit('selecting', this._selectRect);\n      e.preventDefault();\n    }\n  }, {\n    key: \"_keyListener\",\n    value: function _keyListener(e) {\n      this.ctrl = e.metaKey || e.ctrlKey;\n    }\n  }, {\n    key: \"isClick\",\n    value: function isClick(pageX, pageY) {\n      var _this$_initialEventDa2 = this._initialEventData,\n          x = _this$_initialEventDa2.x,\n          y = _this$_initialEventDa2.y,\n          isTouch = _this$_initialEventDa2.isTouch;\n      return !isTouch && Math.abs(pageX - x) <= clickTolerance && Math.abs(pageY - y) <= clickTolerance;\n    }\n  }]);\n\n  return Selection;\n}();\n/**\n * Resolve the disance prop from either an Int or an Object\n * @return {Object}\n */\n\n\nfunction normalizeDistance() {\n  var distance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  if (typeof distance !== 'object') distance = {\n    top: distance,\n    left: distance,\n    right: distance,\n    bottom: distance\n  };\n  return distance;\n}\n/**\n * Given two objects containing \"top\", \"left\", \"offsetWidth\" and \"offsetHeight\"\n * properties, determine if they collide.\n * @param  {Object|HTMLElement} a\n * @param  {Object|HTMLElement} b\n * @return {bool}\n */\n\n\nexport function objectsCollide(nodeA, nodeB) {\n  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  var _getBoundsForNode = getBoundsForNode(nodeA),\n      aTop = _getBoundsForNode.top,\n      aLeft = _getBoundsForNode.left,\n      _getBoundsForNode$rig = _getBoundsForNode.right,\n      aRight = _getBoundsForNode$rig === void 0 ? aLeft : _getBoundsForNode$rig,\n      _getBoundsForNode$bot = _getBoundsForNode.bottom,\n      aBottom = _getBoundsForNode$bot === void 0 ? aTop : _getBoundsForNode$bot;\n\n  var _getBoundsForNode2 = getBoundsForNode(nodeB),\n      bTop = _getBoundsForNode2.top,\n      bLeft = _getBoundsForNode2.left,\n      _getBoundsForNode2$ri = _getBoundsForNode2.right,\n      bRight = _getBoundsForNode2$ri === void 0 ? bLeft : _getBoundsForNode2$ri,\n      _getBoundsForNode2$bo = _getBoundsForNode2.bottom,\n      bBottom = _getBoundsForNode2$bo === void 0 ? bTop : _getBoundsForNode2$bo;\n\n  return !( // 'a' bottom doesn't touch 'b' top\n  aBottom - tolerance < bTop || // 'a' top doesn't touch 'b' bottom\n  aTop + tolerance > bBottom || // 'a' right doesn't touch 'b' left\n  aRight - tolerance < bLeft || // 'a' left doesn't touch 'b' right\n  aLeft + tolerance > bRight);\n}\n/**\n * Given a node, get everything needed to calculate its boundaries\n * @param  {HTMLElement} node\n * @return {Object}\n */\n\nexport function getBoundsForNode(node) {\n  if (!node.getBoundingClientRect) return node;\n  var rect = node.getBoundingClientRect(),\n      left = rect.left + pageOffset('left'),\n      top = rect.top + pageOffset('top');\n  return {\n    top: top,\n    left: left,\n    right: (node.offsetWidth || 0) + left,\n    bottom: (node.offsetHeight || 0) + top\n  };\n}\n\nfunction pageOffset(dir) {\n  if (dir === 'left') return window.pageXOffset || document.body.scrollLeft || 0;\n  if (dir === 'top') return window.pageYOffset || document.body.scrollTop || 0;\n}\n\nexport default Selection;","map":{"version":3,"sources":["/Users/yukoenqvist/personaltrainer/src/Selection.js"],"names":["contains","closest","events","addEventListener","type","handler","target","document","on","remove","off","isOverContainer","container","x","y","elementFromPoint","isEvent","node","clientX","clientY","getEventCoordinates","e","touches","length","pageX","pageY","clickTolerance","clickInterval","Selection","global","longPressThreshold","globalMouse","_listeners","Object","create","_handleInitialEvent","bind","_handleMoveEvent","_handleTerminatingEvent","_keyListener","_onTouchMoveWindowListener","window","_onKeyDownListener","_onKeyUpListener","_addInitialEventListener","handlers","push","idx","indexOf","splice","args","result","forEach","fn","undefined","listeners","_onInitialEventListener","_onEndListener","_onMoveListener","box","_selectRect","selecting","objectsCollide","getBoundsForNode","items","filter","isSelected","initialEvent","timer","touchMoveListener","touchEndListener","handleTouchStart","setTimeout","cleanup","touchStartListener","clearTimeout","mouseDownListener","_addLongPressListener","collides","offsetData","which","button","normalizeDistance","top","left","bottom","right","emit","_initialEventData","isTouch","test","inRoot","bounds","click","isClick","_handleClickEvent","now","Date","getTime","_lastClickData","timestamp","w","Math","abs","h","min","old","preventDefault","ctrl","metaKey","ctrlKey","distance","nodeA","nodeB","tolerance","aTop","aLeft","aRight","aBottom","bTop","bLeft","bRight","bBottom","getBoundingClientRect","rect","pageOffset","offsetWidth","offsetHeight","dir","pageXOffset","body","scrollLeft","pageYOffset","scrollTop"],"mappings":";;AAAA,OAAOA,QAAP,MAAqB,4BAArB;AACA,OAAOC,OAAP,MAAoB,2BAApB;AACA,OAAOC,MAAP,MAAmB,oBAAnB;;AAEA,SAASC,gBAAT,CAA0BC,IAA1B,EAAgCC,OAAhC,EAA4D;AAAA,MAAnBC,MAAmB,uEAAVC,QAAU;AAC1DL,EAAAA,MAAM,CAACM,EAAP,CAAUF,MAAV,EAAkBF,IAAlB,EAAwBC,OAAxB;AACA,SAAO;AACLI,IAAAA,MADK,oBACG;AAAEP,MAAAA,MAAM,CAACQ,GAAP,CAAWJ,MAAX,EAAmBF,IAAnB,EAAyBC,OAAzB;AAAmC;AADxC,GAAP;AAGD;;AAED,SAASM,eAAT,CAAyBC,SAAzB,EAAoCC,CAApC,EAAuCC,CAAvC,EAA0C;AACxC,SAAO,CAACF,SAAD,IAAcZ,QAAQ,CAACY,SAAD,EAAYL,QAAQ,CAACQ,gBAAT,CAA0BF,CAA1B,EAA6BC,CAA7B,CAAZ,CAA7B;AACD;;AAED,OAAO,SAASE,OAAT,CAAiBC,IAAjB,QAA8C;AAAA,MAArBC,OAAqB,QAArBA,OAAqB;AAAA,MAAZC,OAAY,QAAZA,OAAY;AACnD,MAAIb,MAAM,GAAGC,QAAQ,CAACQ,gBAAT,CAA0BG,OAA1B,EAAmCC,OAAnC,CAAb;AACA,SAAO,CAAC,CAAClB,OAAO,CAACK,MAAD,EAAS,YAAT,EAAuBW,IAAvB,CAAhB;AACD;;AAED,SAASG,mBAAT,CAA6BC,CAA7B,EAAgC;AAC9B,MAAIf,MAAM,GAAGe,CAAb;;AAEA,MAAIA,CAAC,CAACC,OAAF,IAAaD,CAAC,CAACC,OAAF,CAAUC,MAA3B,EAAmC;AACjCjB,IAAAA,MAAM,GAAGe,CAAC,CAACC,OAAF,CAAU,CAAV,CAAT;AACD;;AAED,SAAO;AACLJ,IAAAA,OAAO,EAAEZ,MAAM,CAACY,OADX;AAELC,IAAAA,OAAO,EAAEb,MAAM,CAACa,OAFX;AAGLK,IAAAA,KAAK,EAAElB,MAAM,CAACkB,KAHT;AAILC,IAAAA,KAAK,EAAEnB,MAAM,CAACmB;AAJT,GAAP;AAMD;;AAED,IAAMC,cAAc,GAAG,CAAvB;AACA,IAAMC,aAAa,GAAG,GAAtB;;IAEMC,S;;;AAEJ,qBAAYX,IAAZ,EAAqE;AAAA,oFAAJ,EAAI;AAAA,6BAAjDY,MAAiD;AAAA,QAAjDA,MAAiD,6BAAxC,KAAwC;AAAA,sCAAjCC,kBAAiC;AAAA,QAAjCA,kBAAiC,sCAAZ,GAAY;;AAAA;;AACnE,SAAKlB,SAAL,GAAiBK,IAAjB;AACA,SAAKc,WAAL,GAAmB,CAACd,IAAD,IAASY,MAA5B;AACA,SAAKC,kBAAL,GAA0BA,kBAA1B;AAEA,SAAKE,UAAL,GAAkBC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAlB;AAEA,SAAKC,mBAAL,GAA2B,KAAKA,mBAAL,CAAyBC,IAAzB,CAA8B,IAA9B,CAA3B;AACA,SAAKC,gBAAL,GAAwB,KAAKA,gBAAL,CAAsBD,IAAtB,CAA2B,IAA3B,CAAxB;AACA,SAAKE,uBAAL,GAA+B,KAAKA,uBAAL,CAA6BF,IAA7B,CAAkC,IAAlC,CAA/B;AACA,SAAKG,YAAL,GAAoB,KAAKA,YAAL,CAAkBH,IAAlB,CAAuB,IAAvB,CAApB,CAVmE,CAYnE;AACA;;AACA,SAAKI,0BAAL,GAAkCrC,gBAAgB,CAAC,WAAD,EAAc,YAAM,CAAE,CAAtB,EAAwBsC,MAAxB,CAAlD;AACA,SAAKC,kBAAL,GAA0BvC,gBAAgB,CAAC,SAAD,EAAY,KAAKoC,YAAjB,CAA1C;AACA,SAAKI,gBAAL,GAAwBxC,gBAAgB,CAAC,OAAD,EAAU,KAAKoC,YAAf,CAAxC;;AACA,SAAKK,wBAAL;AACD;;;;uBAEExC,I,EAAMC,O,EAAS;AAChB,UAAIwC,QAAQ,GAAG,KAAKb,UAAL,CAAgB5B,IAAhB,MAA0B,KAAK4B,UAAL,CAAgB5B,IAAhB,IAAwB,EAAlD,CAAf;AAEAyC,MAAAA,QAAQ,CAACC,IAAT,CAAczC,OAAd;AAEA,aAAO;AACLI,QAAAA,MADK,oBACG;AACN,cAAIsC,GAAG,GAAGF,QAAQ,CAACG,OAAT,CAAiB3C,OAAjB,CAAV;AACA,cAAI0C,GAAG,KAAK,CAAC,CAAb,EAAgBF,QAAQ,CAACI,MAAT,CAAgBF,GAAhB,EAAqB,CAArB;AACjB;AAJI,OAAP;AAMD;;;yBAEI3C,I,EAAc;AAAA,wCAAL8C,IAAK;AAALA,QAAAA,IAAK;AAAA;;AACjB,UAAIC,MAAJ;AACA,UAAIN,QAAQ,GAAG,KAAKb,UAAL,CAAgB5B,IAAhB,KAAyB,EAAxC;AACAyC,MAAAA,QAAQ,CAACO,OAAT,CAAiB,UAAAC,EAAE,EAAI;AACrB,YAAIF,MAAM,KAAKG,SAAf,EACEH,MAAM,GAAGE,EAAE,MAAF,SAAMH,IAAN,CAAT;AACH,OAHD;AAIA,aAAOC,MAAP;AACD;;;+BAEU;AACT,WAAKI,SAAL,GAAiBtB,MAAM,CAACC,MAAP,CAAc,IAAd,CAAjB;AACA,WAAKM,0BAAL,IAAmC,KAAKA,0BAAL,CAAgC/B,MAAhC,EAAnC;AACA,WAAK+C,uBAAL,IAAgC,KAAKA,uBAAL,CAA6B/C,MAA7B,EAAhC;AACA,WAAKgD,cAAL,IAAuB,KAAKA,cAAL,CAAoBhD,MAApB,EAAvB;AACA,WAAKiD,eAAL,IAAwB,KAAKA,eAAL,CAAqBjD,MAArB,EAAxB;AACA,WAAKkC,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBlC,MAAtB,EAAzB;AACA,WAAKiC,kBAAL,IAA2B,KAAKA,kBAAL,CAAwBjC,MAAxB,EAA3B;AACD;;;+BAEUQ,I,EAAK;AACd,UAAI0C,GAAG,GAAG,KAAKC,WAAf;AAEA,UAAI,CAACD,GAAD,IAAQ,CAAC,KAAKE,SAAlB,EAA6B,OAAO,KAAP;AAE7B,aAAOC,cAAc,CAACH,GAAD,EAAMI,gBAAgB,CAAC9C,IAAD,CAAtB,CAArB;AACD;;;2BAEM+C,K,EAAO;AACZ,UAAIL,GAAG,GAAG,KAAKC,WAAf,CADY,CAGZ;;AACA,UAAI,CAACD,GAAD,IAAQ,CAAC,KAAKE,SAAlB,EACE,OAAO,EAAP;AAEF,aAAOG,KAAK,CAACC,MAAN,CAAa,KAAKC,UAAlB,EAA8B,IAA9B,CAAP;AACD,K,CAED;AACA;;;;0CACsB7D,O,EAAS8D,Y,EAAc;AAAA;;AAC3C,UAAIC,KAAK,GAAG,IAAZ;AACA,UAAIC,iBAAiB,GAAG,IAAxB;AACA,UAAIC,gBAAgB,GAAG,IAAvB;;AACA,UAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACJ,YAAD,EAAkB;AACzCC,QAAAA,KAAK,GAAGI,UAAU,CAAC,YAAM;AACvBC,UAAAA,OAAO;AACPpE,UAAAA,OAAO,CAAC8D,YAAD,CAAP;AACD,SAHiB,EAGf,KAAI,CAACrC,kBAHU,CAAlB;AAIAuC,QAAAA,iBAAiB,GAAGlE,gBAAgB,CAAC,WAAD,EAAc;AAAA,iBAAMsE,OAAO,EAAb;AAAA,SAAd,CAApC;AACAH,QAAAA,gBAAgB,GAAGnE,gBAAgB,CAAC,UAAD,EAAa;AAAA,iBAAMsE,OAAO,EAAb;AAAA,SAAb,CAAnC;AACD,OAPD;;AAQA,UAAMC,kBAAkB,GAAGvE,gBAAgB,CAAC,YAAD,EAAeoE,gBAAf,CAA3C;;AACA,UAAME,OAAO,GAAG,SAAVA,OAAU,GAAM;AACpB,YAAIL,KAAJ,EAAW;AAAEO,UAAAA,YAAY,CAACP,KAAD,CAAZ;AAAsB;;AACnC,YAAIC,iBAAJ,EAAuB;AAAEA,UAAAA,iBAAiB,CAAC5D,MAAlB;AAA6B;;AACtD,YAAI6D,gBAAJ,EAAsB;AAAEA,UAAAA,gBAAgB,CAAC7D,MAAjB;AAA4B;;AAEpD2D,QAAAA,KAAK,GAAG,IAAR;AACAC,QAAAA,iBAAiB,GAAG,IAApB;AACAC,QAAAA,gBAAgB,GAAG,IAAnB;AACD,OARD;;AAUA,UAAIH,YAAJ,EAAkB;AAChBI,QAAAA,gBAAgB,CAACJ,YAAD,CAAhB;AACD;;AAED,aAAO;AACL1D,QAAAA,MADK,oBACI;AACPgE,UAAAA,OAAO;AACPC,UAAAA,kBAAkB,CAACjE,MAAnB;AACD;AAJI,OAAP;AAMD,K,CAED;AACA;;;;+CAC2B;AAAA;;AACzB,UAAMmE,iBAAiB,GAAGzE,gBAAgB,CAAC,WAAD,EAAc,UAACkB,CAAD,EAAO;AAC7D,QAAA,MAAI,CAACmC,uBAAL,CAA6B/C,MAA7B;;AACA,QAAA,MAAI,CAAC0B,mBAAL,CAAyBd,CAAzB;;AACA,QAAA,MAAI,CAACmC,uBAAL,GAA+BrD,gBAAgB,CAAC,WAAD,EAAc,MAAI,CAACgC,mBAAnB,CAA/C;AACD,OAJyC,CAA1C;AAKA,UAAMuC,kBAAkB,GAAGvE,gBAAgB,CAAC,YAAD,EAAe,UAACkB,CAAD,EAAO;AAC/D,QAAA,MAAI,CAACmC,uBAAL,CAA6B/C,MAA7B;;AACA,QAAA,MAAI,CAAC+C,uBAAL,GAA+B,MAAI,CAACqB,qBAAL,CAA2B,MAAI,CAAC1C,mBAAhC,EAAqDd,CAArD,CAA/B;AACD,OAH0C,CAA3C;AAKA,WAAKmC,uBAAL,GAA+B;AAC7B/C,QAAAA,MAD6B,oBACpB;AACPmE,UAAAA,iBAAiB,CAACnE,MAAlB;AACAiE,UAAAA,kBAAkB,CAACjE,MAAnB;AACD;AAJ4B,OAA/B;AAMD;;;wCAEoBY,C,EAAG;AAAA,iCACqBD,mBAAmB,CAACC,CAAD,CADxC;AAAA,UACdH,OADc,wBACdA,OADc;AAAA,UACLC,OADK,wBACLA,OADK;AAAA,UACIK,KADJ,wBACIA,KADJ;AAAA,UACWC,KADX,wBACWA,KADX;;AAEtB,UAAIR,IAAI,GAAG,KAAKL,SAAL,EAAX;AAAA,UACIkE,QADJ;AAAA,UACcC,UADd,CAFsB,CAKtB;;AACA,UACE1D,CAAC,CAAC2D,KAAF,KAAY,CAAZ,IACA3D,CAAC,CAAC4D,MAAF,KAAa,CADb,IAEA,CAACtE,eAAe,CAACM,IAAD,EAAOC,OAAP,EAAgBC,OAAhB,CAHlB,EAME;;AAEF,UAAI,CAAC,KAAKY,WAAN,IAAqBd,IAArB,IAA6B,CAACjB,QAAQ,CAACiB,IAAD,EAAOI,CAAC,CAACf,MAAT,CAA1C,EAA4D;AAAA,iCAEvB4E,iBAAiB,CAAC,CAAD,CAFM;AAAA,YAEpDC,GAFoD,sBAEpDA,GAFoD;AAAA,YAE/CC,IAF+C,sBAE/CA,IAF+C;AAAA,YAEzCC,MAFyC,sBAEzCA,MAFyC;AAAA,YAEjCC,KAFiC,sBAEjCA,KAFiC;;AAI1DP,QAAAA,UAAU,GAAGhB,gBAAgB,CAAC9C,IAAD,CAA7B;AAEA6D,QAAAA,QAAQ,GAAGhB,cAAc,CAAC;AACxBqB,UAAAA,GAAG,EAAEJ,UAAU,CAACI,GAAX,GAAiBA,GADE;AAExBC,UAAAA,IAAI,EAAEL,UAAU,CAACK,IAAX,GAAkBA,IAFA;AAGxBC,UAAAA,MAAM,EAAEN,UAAU,CAACM,MAAX,GAAoBA,MAHJ;AAIxBC,UAAAA,KAAK,EAAEP,UAAU,CAACO,KAAX,GAAmBA;AAJF,SAAD,EAMzB;AAAEH,UAAAA,GAAG,EAAE1D,KAAP;AAAc2D,UAAAA,IAAI,EAAE5D;AAApB,SANyB,CAAzB;AAQA,YAAI,CAACsD,QAAL,EAAe;AAChB;;AAED,UAAI3B,MAAM,GAAG,KAAKoC,IAAL,CAAU,cAAV,EAA0B,KAAKC,iBAAL,GAAyB;AAC9DC,QAAAA,OAAO,EAAE,SAASC,IAAT,CAAcrE,CAAC,CAACjB,IAAhB,CADqD;AAE9DS,QAAAA,CAAC,EAAEW,KAF2D;AAG9DV,QAAAA,CAAC,EAAEW,KAH2D;AAI9DP,QAAAA,OAAO,EAAPA,OAJ8D;AAK9DC,QAAAA,OAAO,EAAPA;AAL8D,OAAnD,CAAb;AAQA,UAAIgC,MAAM,KAAK,KAAf,EACE;;AAEF,cAAQ9B,CAAC,CAACjB,IAAV;AACE,aAAK,WAAL;AACE,eAAKqD,cAAL,GAAsBtD,gBAAgB,CAAC,SAAD,EAAY,KAAKmC,uBAAjB,CAAtC;AACA,eAAKoB,eAAL,GAAuBvD,gBAAgB,CAAC,WAAD,EAAc,KAAKkC,gBAAnB,CAAvC;AACA;;AACF,aAAK,YAAL;AACE,eAAKA,gBAAL,CAAsBhB,CAAtB;;AACA,eAAKoC,cAAL,GAAsBtD,gBAAgB,CAAC,UAAD,EAAa,KAAKmC,uBAAlB,CAAtC;AACA,eAAKoB,eAAL,GAAuBvD,gBAAgB,CAAC,WAAD,EAAc,KAAKkC,gBAAnB,CAAvC;AACA;;AACF;AACE;AAXJ;AAaD;;;4CAEuBhB,C,EAAG;AAAA,kCACAD,mBAAmB,CAACC,CAAD,CADnB;AAAA,UACjBG,KADiB,yBACjBA,KADiB;AAAA,UACVC,KADU,yBACVA,KADU;;AAGzB,WAAKoC,SAAL,GAAiB,KAAjB;AAEA,WAAKJ,cAAL,IAAuB,KAAKA,cAAL,CAAoBhD,MAApB,EAAvB;AACA,WAAKiD,eAAL,IAAwB,KAAKA,eAAL,CAAqBjD,MAArB,EAAxB;AAEA,UAAI,CAAC,KAAK+E,iBAAV,EAA6B;AAE7B,UAAIG,MAAM,GAAG,CAAC,KAAK/E,SAAN,IAAmBZ,QAAQ,CAAC,KAAKY,SAAL,EAAD,EAAmBS,CAAC,CAACf,MAArB,CAAxC;AACA,UAAIsF,MAAM,GAAG,KAAKhC,WAAlB;AACA,UAAIiC,KAAK,GAAG,KAAKC,OAAL,CAAatE,KAAb,EAAoBC,KAApB,CAAZ;AAEA,WAAK+D,iBAAL,GAAyB,IAAzB;;AAEA,UAAGK,KAAK,IAAI,CAACF,MAAb,EAAqB;AACnB,eAAO,KAAKJ,IAAL,CAAU,OAAV,CAAP;AACD;;AAED,UAAGM,KAAK,IAAIF,MAAZ,EAAoB;AAClB,eAAO,KAAKI,iBAAL,CAAuB1E,CAAvB,CAAP;AACD,OAtBwB,CAwBzB;;;AACA,UAAG,CAACwE,KAAJ,EACE,OAAO,KAAKN,IAAL,CAAU,QAAV,EAAoBK,MAApB,CAAP;AACH;;;sCAEiBvE,C,EAAG;AAAA,kCACwBD,mBAAmB,CAACC,CAAD,CAD3C;AAAA,UACXG,KADW,yBACXA,KADW;AAAA,UACJC,KADI,yBACJA,KADI;AAAA,UACGP,OADH,yBACGA,OADH;AAAA,UACYC,OADZ,yBACYA,OADZ;;AAEnB,UAAM6E,GAAG,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAZ;;AAEA,UAAI,KAAKC,cAAL,IAAuBH,GAAG,GAAG,KAAKG,cAAL,CAAoBC,SAA1B,GAAsCzE,aAAjE,EAAgF;AAC9E;AACA,aAAKwE,cAAL,GAAsB,IAAtB;AACA,eAAO,KAAKZ,IAAL,CAAU,aAAV,EAAyB;AAC9B1E,UAAAA,CAAC,EAAEW,KAD2B;AAE9BV,UAAAA,CAAC,EAAEW,KAF2B;AAG9BP,UAAAA,OAAO,EAAEA,OAHqB;AAI9BC,UAAAA,OAAO,EAAEA;AAJqB,SAAzB,CAAP;AAMD,OAbkB,CAenB;;;AACA,WAAKgF,cAAL,GAAsB;AACpBC,QAAAA,SAAS,EAAEJ;AADS,OAAtB;AAGA,aAAO,KAAKT,IAAL,CAAU,OAAV,EAAmB;AACxB1E,QAAAA,CAAC,EAAEW,KADqB;AAExBV,QAAAA,CAAC,EAAEW,KAFqB;AAGxBP,QAAAA,OAAO,EAAEA,OAHe;AAIxBC,QAAAA,OAAO,EAAEA;AAJe,OAAnB,CAAP;AAMD;;;qCAEgBE,C,EAAG;AAAA,kCACH,KAAKmE,iBADF;AAAA,UACZ3E,CADY,yBACZA,CADY;AAAA,UACTC,CADS,yBACTA,CADS;;AAAA,kCAEOM,mBAAmB,CAACC,CAAD,CAF1B;AAAA,UAEVG,KAFU,yBAEVA,KAFU;AAAA,UAEHC,KAFG,yBAEHA,KAFG;;AAGlB,UAAI4E,CAAC,GAAGC,IAAI,CAACC,GAAL,CAAS1F,CAAC,GAAGW,KAAb,CAAR;AACA,UAAIgF,CAAC,GAAGF,IAAI,CAACC,GAAL,CAASzF,CAAC,GAAGW,KAAb,CAAR;AAEA,UAAI2D,IAAI,GAAGkB,IAAI,CAACG,GAAL,CAASjF,KAAT,EAAgBX,CAAhB,CAAX;AAAA,UACIsE,GAAG,GAAGmB,IAAI,CAACG,GAAL,CAAShF,KAAT,EAAgBX,CAAhB,CADV;AAAA,UAEI4F,GAAG,GAAG,KAAK7C,SAFf;AAIA,WAAKA,SAAL,GAAiB,IAAjB;AACA,WAAKD,WAAL,GAAmB;AACjBuB,QAAAA,GAAG,EAAHA,GADiB;AAEjBC,QAAAA,IAAI,EAAJA,IAFiB;AAGjBvE,QAAAA,CAAC,EAAEW,KAHc;AAIjBV,QAAAA,CAAC,EAAEW,KAJc;AAKjB6D,QAAAA,KAAK,EAAEF,IAAI,GAAGiB,CALG;AAMjBhB,QAAAA,MAAM,EAAEF,GAAG,GAAGqB;AANG,OAAnB;;AASA,UAAI,CAACE,GAAL,EAAU;AACR,aAAKnB,IAAL,CAAU,aAAV,EAAyB,KAAKC,iBAA9B;AACD;;AAED,UAAI,CAAC,KAAKM,OAAL,CAAatE,KAAb,EAAoBC,KAApB,CAAL,EACE,KAAK8D,IAAL,CAAU,WAAV,EAAuB,KAAK3B,WAA5B;AAEFvC,MAAAA,CAAC,CAACsF,cAAF;AACD;;;iCAEYtF,C,EAAG;AACd,WAAKuF,IAAL,GAAavF,CAAC,CAACwF,OAAF,IAAaxF,CAAC,CAACyF,OAA5B;AACD;;;4BAEOtF,K,EAAOC,K,EAAM;AAAA,mCACK,KAAK+D,iBADV;AAAA,UACb3E,CADa,0BACbA,CADa;AAAA,UACVC,CADU,0BACVA,CADU;AAAA,UACP2E,OADO,0BACPA,OADO;AAEnB,aAAO,CAACA,OAAD,IACLa,IAAI,CAACC,GAAL,CAAS/E,KAAK,GAAGX,CAAjB,KAAuBa,cAAvB,IACA4E,IAAI,CAACC,GAAL,CAAS9E,KAAK,GAAGX,CAAjB,KAAuBY,cAFzB;AAID;;;;;AAGH;;;;;;AAIA,SAASwD,iBAAT,GAAyC;AAAA,MAAd6B,QAAc,uEAAH,CAAG;AACvC,MAAI,OAAOA,QAAP,KAAoB,QAAxB,EACEA,QAAQ,GAAG;AAAE5B,IAAAA,GAAG,EAAE4B,QAAP;AAAiB3B,IAAAA,IAAI,EAAE2B,QAAvB;AAAiCzB,IAAAA,KAAK,EAAEyB,QAAxC;AAAkD1B,IAAAA,MAAM,EAAE0B;AAA1D,GAAX;AAEF,SAAOA,QAAP;AACD;AAED;;;;;;;;;AAOA,OAAO,SAASjD,cAAT,CAAwBkD,KAAxB,EAA+BC,KAA/B,EAAqD;AAAA,MAAfC,SAAe,uEAAH,CAAG;;AAAA,0BACsBnD,gBAAgB,CAACiD,KAAD,CADtC;AAAA,MAC/CG,IAD+C,qBACpDhC,GADoD;AAAA,MACnCiC,KADmC,qBACzChC,IADyC;AAAA,gDAC5BE,KAD4B;AAAA,MACrB+B,MADqB,sCACZD,KADY;AAAA,gDACL/B,MADK;AAAA,MACGiC,OADH,sCACaH,IADb;;AAAA,2BAEsBpD,gBAAgB,CAACkD,KAAD,CAFtC;AAAA,MAE/CM,IAF+C,sBAEpDpC,GAFoD;AAAA,MAEnCqC,KAFmC,sBAEzCpC,IAFyC;AAAA,iDAE5BE,KAF4B;AAAA,MAErBmC,MAFqB,sCAEZD,KAFY;AAAA,iDAELnC,MAFK;AAAA,MAEGqC,OAFH,sCAEaH,IAFb;;AAI1D,SAAO,GACL;AACED,EAAAA,OAAO,GAAGJ,SAAX,GAAyBK,IAA1B,IACA;AACEJ,EAAAA,IAAI,GAAGD,SAAR,GAAsBQ,OAFvB,IAGA;AACEL,EAAAA,MAAM,GAAGH,SAAV,GAAuBM,KAJxB,IAKA;AACEJ,EAAAA,KAAK,GAAGF,SAAT,GAAuBO,MARnB,CAAP;AAUD;AAED;;;;;;AAKA,OAAO,SAAS1D,gBAAT,CAA0B9C,IAA1B,EAAgC;AACrC,MAAI,CAACA,IAAI,CAAC0G,qBAAV,EAAiC,OAAO1G,IAAP;AAEjC,MAAI2G,IAAI,GAAG3G,IAAI,CAAC0G,qBAAL,EAAX;AAAA,MACIvC,IAAI,GAAGwC,IAAI,CAACxC,IAAL,GAAYyC,UAAU,CAAC,MAAD,CADjC;AAAA,MAEI1C,GAAG,GAAGyC,IAAI,CAACzC,GAAL,GAAW0C,UAAU,CAAC,KAAD,CAF/B;AAIA,SAAO;AACL1C,IAAAA,GAAG,EAAHA,GADK;AAELC,IAAAA,IAAI,EAAJA,IAFK;AAGLE,IAAAA,KAAK,EAAE,CAACrE,IAAI,CAAC6G,WAAL,IAAoB,CAArB,IAA0B1C,IAH5B;AAILC,IAAAA,MAAM,EAAE,CAACpE,IAAI,CAAC8G,YAAL,IAAqB,CAAtB,IAA2B5C;AAJ9B,GAAP;AAMD;;AAED,SAAS0C,UAAT,CAAoBG,GAApB,EAAyB;AACvB,MAAIA,GAAG,KAAK,MAAZ,EACE,OAAQvF,MAAM,CAACwF,WAAP,IAAsB1H,QAAQ,CAAC2H,IAAT,CAAcC,UAApC,IAAkD,CAA1D;AACF,MAAIH,GAAG,KAAK,KAAZ,EACE,OAAQvF,MAAM,CAAC2F,WAAP,IAAsB7H,QAAQ,CAAC2H,IAAT,CAAcG,SAApC,IAAiD,CAAzD;AACH;;AACD,eAAezG,SAAf","sourcesContent":["import contains from 'dom-helpers/query/contains';\nimport closest from 'dom-helpers/query/closest';\nimport events from 'dom-helpers/events';\n\nfunction addEventListener(type, handler, target = document) {\n  events.on(target, type, handler)\n  return {\n    remove(){ events.off(target, type, handler) }\n  }\n}\n\nfunction isOverContainer(container, x, y) {\n  return !container || contains(container, document.elementFromPoint(x, y))\n}\n\nexport function isEvent(node, { clientX, clientY, }) {\n  let target = document.elementFromPoint(clientX, clientY);\n  return !!closest(target, '.rbc-event', node)\n}\n\nfunction getEventCoordinates(e) {\n  let target = e;\n\n  if (e.touches && e.touches.length) {\n    target = e.touches[0];\n  }\n\n  return {\n    clientX: target.clientX,\n    clientY: target.clientY,\n    pageX: target.pageX,\n    pageY: target.pageY\n  };\n}\n\nconst clickTolerance = 5;\nconst clickInterval = 250;\n\nclass Selection {\n\n  constructor(node, { global = false, longPressThreshold = 250 } = {}) {\n    this.container = node;\n    this.globalMouse = !node || global;\n    this.longPressThreshold = longPressThreshold;\n\n    this._listeners = Object.create(null);\n\n    this._handleInitialEvent = this._handleInitialEvent.bind(this)\n    this._handleMoveEvent = this._handleMoveEvent.bind(this)\n    this._handleTerminatingEvent = this._handleTerminatingEvent.bind(this)\n    this._keyListener = this._keyListener.bind(this)\n\n    // Fixes an iOS 10 bug where scrolling could not be prevented on the window.\n    // https://github.com/metafizzy/flickity/issues/457#issuecomment-254501356\n    this._onTouchMoveWindowListener = addEventListener('touchmove', () => {}, window);\n    this._onKeyDownListener = addEventListener('keydown', this._keyListener)\n    this._onKeyUpListener = addEventListener('keyup', this._keyListener)\n    this._addInitialEventListener();\n  }\n\n  on(type, handler) {\n    let handlers = this._listeners[type] || (this._listeners[type] = []);\n\n    handlers.push(handler);\n\n    return {\n      remove(){\n        let idx = handlers.indexOf(handler);\n        if( idx !== -1) handlers.splice(idx, 1)\n      }\n    }\n  }\n\n  emit(type, ...args){\n    let result;\n    let handlers = this._listeners[type] || [];\n    handlers.forEach(fn => {\n      if (result === undefined)\n        result = fn(...args);\n    })\n    return result;\n  }\n\n  teardown() {\n    this.listeners = Object.create(null)\n    this._onTouchMoveWindowListener && this._onTouchMoveWindowListener.remove();\n    this._onInitialEventListener && this._onInitialEventListener.remove()\n    this._onEndListener && this._onEndListener.remove();\n    this._onMoveListener && this._onMoveListener.remove();\n    this._onKeyUpListener && this._onKeyUpListener.remove();\n    this._onKeyDownListener && this._onKeyDownListener.remove()\n  }\n\n  isSelected(node){\n    let box = this._selectRect;\n\n    if (!box || !this.selecting) return false;\n\n    return objectsCollide(box, getBoundsForNode(node))\n  }\n\n  filter(items) {\n    let box = this._selectRect;\n\n    //not selecting\n    if (!box || !this.selecting)\n      return [];\n\n    return items.filter(this.isSelected, this)\n  }\n\n  // Adds a listener that will call the handler only after the user has pressed on the screen\n  // without moving their finger for 250ms.\n  _addLongPressListener(handler, initialEvent) {\n    let timer = null;\n    let touchMoveListener = null;\n    let touchEndListener = null;\n    const handleTouchStart = (initialEvent) => {\n      timer = setTimeout(() => {\n        cleanup();\n        handler(initialEvent);\n      }, this.longPressThreshold);\n      touchMoveListener = addEventListener('touchmove', () => cleanup());\n      touchEndListener = addEventListener('touchend', () => cleanup());\n    };\n    const touchStartListener = addEventListener('touchstart', handleTouchStart);\n    const cleanup = () => {\n      if (timer) { clearTimeout(timer); }\n      if (touchMoveListener) { touchMoveListener.remove(); }\n      if (touchEndListener) { touchEndListener.remove(); }\n\n      timer = null;\n      touchMoveListener = null;\n      touchEndListener = null;\n    }\n\n    if (initialEvent) {\n      handleTouchStart(initialEvent);\n    }\n\n    return {\n      remove() {\n        cleanup();\n        touchStartListener.remove();\n      },\n    };\n  }\n\n  // Listen for mousedown and touchstart events. When one is received, disable the other and setup\n  // future event handling based on the type of event.\n  _addInitialEventListener() {\n    const mouseDownListener = addEventListener('mousedown', (e) => {\n      this._onInitialEventListener.remove();\n      this._handleInitialEvent(e);\n      this._onInitialEventListener = addEventListener('mousedown', this._handleInitialEvent);\n    });\n    const touchStartListener = addEventListener('touchstart', (e) => {\n      this._onInitialEventListener.remove();\n      this._onInitialEventListener = this._addLongPressListener(this._handleInitialEvent, e);\n    });\n\n    this._onInitialEventListener = {\n      remove() {\n        mouseDownListener.remove();\n        touchStartListener.remove();\n      },\n    };\n  }\n\n  _handleInitialEvent (e) {\n    const { clientX, clientY, pageX, pageY } = getEventCoordinates(e);\n    let node = this.container()\n      , collides, offsetData;\n\n    // Right clicks\n    if (\n      e.which === 3 ||\n      e.button === 2 ||\n      !isOverContainer(node, clientX, clientY)\n\n    )\n      return;\n\n    if (!this.globalMouse && node && !contains(node, e.target)) {\n\n      let { top, left, bottom, right } = normalizeDistance(0);\n\n      offsetData = getBoundsForNode(node);\n\n      collides = objectsCollide({\n        top: offsetData.top - top,\n        left: offsetData.left - left,\n        bottom: offsetData.bottom + bottom,\n        right: offsetData.right + right\n      },\n      { top: pageY, left: pageX });\n\n      if (!collides) return;\n    }\n\n    let result = this.emit('beforeSelect', this._initialEventData = {\n      isTouch: /^touch/.test(e.type),\n      x: pageX,\n      y: pageY,\n      clientX,\n      clientY,\n    });\n\n    if (result === false)\n      return;\n\n    switch (e.type) {\n      case 'mousedown':\n        this._onEndListener = addEventListener('mouseup', this._handleTerminatingEvent)\n        this._onMoveListener = addEventListener('mousemove', this._handleMoveEvent)\n        break;\n      case 'touchstart':\n        this._handleMoveEvent(e);\n        this._onEndListener = addEventListener('touchend', this._handleTerminatingEvent)\n        this._onMoveListener = addEventListener('touchmove', this._handleMoveEvent)\n        break;\n      default:\n        break;\n    }\n  }\n\n  _handleTerminatingEvent(e) {\n    const { pageX, pageY } = getEventCoordinates(e);\n\n    this.selecting = false;\n\n    this._onEndListener && this._onEndListener.remove();\n    this._onMoveListener && this._onMoveListener.remove();\n\n    if (!this._initialEventData) return;\n\n    let inRoot = !this.container || contains(this.container(), e.target);\n    let bounds = this._selectRect;\n    let click = this.isClick(pageX, pageY);\n\n    this._initialEventData = null\n\n    if(click && !inRoot) {\n      return this.emit('reset')\n    }\n\n    if(click && inRoot) {\n      return this._handleClickEvent(e);\n    }\n\n    // User drag-clicked in the Selectable area\n    if(!click)\n      return this.emit('select', bounds)\n  }\n\n  _handleClickEvent(e) {\n    const { pageX, pageY, clientX, clientY } = getEventCoordinates(e);\n    const now = new Date().getTime();\n\n    if (this._lastClickData && now - this._lastClickData.timestamp < clickInterval) {\n      // Double click event\n      this._lastClickData = null;\n      return this.emit('doubleClick', {\n        x: pageX,\n        y: pageY,\n        clientX: clientX,\n        clientY: clientY,\n      })\n    }\n\n    // Click event\n    this._lastClickData = {\n      timestamp: now,\n    };\n    return this.emit('click', {\n      x: pageX,\n      y: pageY,\n      clientX: clientX,\n      clientY: clientY,\n    });\n  }\n\n  _handleMoveEvent(e) {\n    let { x, y } = this._initialEventData;\n    const { pageX, pageY } = getEventCoordinates(e);\n    let w = Math.abs(x - pageX);\n    let h = Math.abs(y - pageY);\n\n    let left = Math.min(pageX, x)\n      , top = Math.min(pageY, y)\n      , old = this.selecting;\n\n    this.selecting = true;\n    this._selectRect = {\n      top,\n      left,\n      x: pageX,\n      y: pageY,\n      right: left + w,\n      bottom: top + h\n    };\n\n    if (!old) {\n      this.emit('selectStart', this._initialEventData);\n    }\n\n    if (!this.isClick(pageX, pageY))\n      this.emit('selecting', this._selectRect);\n\n    e.preventDefault();\n  }\n\n  _keyListener(e) {\n    this.ctrl = (e.metaKey || e.ctrlKey)\n  }\n\n  isClick(pageX, pageY){\n    let { x, y, isTouch } = this._initialEventData;\n    return !isTouch && (\n      Math.abs(pageX - x) <= clickTolerance &&\n      Math.abs(pageY - y) <= clickTolerance\n    );\n  }\n}\n\n/**\n * Resolve the disance prop from either an Int or an Object\n * @return {Object}\n */\nfunction normalizeDistance(distance = 0) {\n  if (typeof distance !== 'object')\n    distance = { top: distance, left: distance, right: distance, bottom: distance };\n\n  return distance;\n}\n\n/**\n * Given two objects containing \"top\", \"left\", \"offsetWidth\" and \"offsetHeight\"\n * properties, determine if they collide.\n * @param  {Object|HTMLElement} a\n * @param  {Object|HTMLElement} b\n * @return {bool}\n */\nexport function objectsCollide(nodeA, nodeB, tolerance = 0) {\n  let { top: aTop, left: aLeft, right: aRight = aLeft, bottom: aBottom = aTop } = getBoundsForNode(nodeA);\n  let { top: bTop, left: bLeft, right: bRight = bLeft, bottom: bBottom = bTop } = getBoundsForNode(nodeB);\n\n  return !(\n    // 'a' bottom doesn't touch 'b' top\n    ((aBottom - tolerance ) < bTop)  ||\n    // 'a' top doesn't touch 'b' bottom\n    ((aTop + tolerance) > (bBottom)) ||\n    // 'a' right doesn't touch 'b' left\n    ((aRight - tolerance) < bLeft )  ||\n    // 'a' left doesn't touch 'b' right\n    ((aLeft + tolerance) > (bRight) )\n  );\n}\n\n/**\n * Given a node, get everything needed to calculate its boundaries\n * @param  {HTMLElement} node\n * @return {Object}\n */\nexport function getBoundsForNode(node) {\n  if (!node.getBoundingClientRect) return node;\n\n  let rect = node.getBoundingClientRect()\n    , left = rect.left + pageOffset('left')\n    , top = rect.top + pageOffset('top');\n\n  return {\n    top,\n    left,\n    right: (node.offsetWidth || 0) + left,\n    bottom: (node.offsetHeight || 0) + top\n  };\n}\n\nfunction pageOffset(dir) {\n  if (dir === 'left')\n    return (window.pageXOffset || document.body.scrollLeft || 0)\n  if (dir === 'top')\n    return (window.pageYOffset || document.body.scrollTop || 0)\n}\nexport default Selection\n"]},"metadata":{},"sourceType":"module"}