{"ast":null,"code":"import findIndex from 'lodash/findIndex';\nimport dates from './dates';\nimport { accessor as get } from './accessors';\nexport function endOfRange(dateRange) {\n  var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'day';\n  return {\n    first: dateRange[0],\n    last: dates.add(dateRange[dateRange.length - 1], 1, unit)\n  };\n}\nexport function eventSegments(event, first, last, _ref, range) {\n  var startAccessor = _ref.startAccessor,\n      endAccessor = _ref.endAccessor;\n  var slots = dates.diff(first, last, 'day');\n  var start = dates.max(dates.startOf(get(event, startAccessor), 'day'), first);\n  var end = dates.min(dates.ceil(get(event, endAccessor), 'day'), last);\n  var padding = findIndex(range, function (x) {\n    return dates.eq(x, start, 'day');\n  });\n  var span = dates.diff(start, end, 'day');\n  span = Math.min(span, slots);\n  span = Math.max(span, 1);\n  return {\n    event: event,\n    span: span,\n    left: padding + 1,\n    right: Math.max(padding + span, 1)\n  };\n}\nexport function segStyle(span, slots) {\n  var per = span / slots * 100 + '%';\n  return {\n    WebkitFlexBasis: per,\n    flexBasis: per,\n    maxWidth: per // IE10/11 need max-width. flex-basis doesn't respect box-sizing\n\n  };\n}\nexport function eventLevels(rowSegments) {\n  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  var i,\n      j,\n      seg,\n      levels = [],\n      extra = [];\n\n  for (i = 0; i < rowSegments.length; i++) {\n    seg = rowSegments[i];\n\n    for (j = 0; j < levels.length; j++) {\n      if (!segsOverlap(seg, levels[j])) break;\n    }\n\n    if (j >= limit) {\n      extra.push(seg);\n    } else {\n      (levels[j] || (levels[j] = [])).push(seg);\n    }\n  }\n\n  for (i = 0; i < levels.length; i++) {\n    levels[i].sort(function (a, b) {\n      return a.left - b.left;\n    }); //eslint-disable-line\n  }\n\n  return {\n    levels: levels,\n    extra: extra\n  };\n}\nexport function inRange(e, start, end, _ref2) {\n  var startAccessor = _ref2.startAccessor,\n      endAccessor = _ref2.endAccessor;\n  var eStart = dates.startOf(get(e, startAccessor), 'day');\n  var eEnd = get(e, endAccessor);\n  var startsBeforeEnd = dates.lte(eStart, end, 'day');\n  var endsAfterStart = dates.gte(eEnd, start, 'day');\n  return startsBeforeEnd && endsAfterStart;\n}\nexport function segsOverlap(seg, otherSegs) {\n  return otherSegs.some(function (otherSeg) {\n    return otherSeg.left <= seg.right && otherSeg.right >= seg.left;\n  });\n}\nexport function sortEvents(evtA, evtB, _ref3) {\n  var startAccessor = _ref3.startAccessor,\n      endAccessor = _ref3.endAccessor,\n      allDayAccessor = _ref3.allDayAccessor;\n  var startSort = +dates.startOf(get(evtA, startAccessor), 'day') - +dates.startOf(get(evtB, startAccessor), 'day');\n  var durA = dates.diff(get(evtA, startAccessor), dates.ceil(get(evtA, endAccessor), 'day'), 'day');\n  var durB = dates.diff(get(evtB, startAccessor), dates.ceil(get(evtB, endAccessor), 'day'), 'day');\n  return startSort // sort by start Day first\n  || Math.max(durB, 1) - Math.max(durA, 1) // events spanning multiple days go first\n  || !!get(evtB, allDayAccessor) - !!get(evtA, allDayAccessor) // then allDay single day events\n  || +get(evtA, startAccessor) - +get(evtB, startAccessor); // then sort by start time\n}","map":{"version":3,"sources":["/Users/yukoenqvist/personaltrainer/src/utils/eventLevels.js"],"names":["findIndex","dates","accessor","get","endOfRange","dateRange","unit","first","last","add","length","eventSegments","event","range","startAccessor","endAccessor","slots","diff","start","max","startOf","end","min","ceil","padding","x","eq","span","Math","left","right","segStyle","per","WebkitFlexBasis","flexBasis","maxWidth","eventLevels","rowSegments","limit","Infinity","i","j","seg","levels","extra","segsOverlap","push","sort","a","b","inRange","e","eStart","eEnd","startsBeforeEnd","lte","endsAfterStart","gte","otherSegs","some","otherSeg","sortEvents","evtA","evtB","allDayAccessor","startSort","durA","durB"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,kBAAtB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,SAASC,QAAQ,IAAIC,GAArB,QAAgC,aAAhC;AAEA,OAAO,SAASC,UAAT,CAAoBC,SAApB,EAA6C;AAAA,MAAdC,IAAc,uEAAP,KAAO;AAClD,SAAO;AACLC,IAAAA,KAAK,EAAEF,SAAS,CAAC,CAAD,CADX;AAELG,IAAAA,IAAI,EAAEP,KAAK,CAACQ,GAAN,CAAUJ,SAAS,CAACA,SAAS,CAACK,MAAV,GAAmB,CAApB,CAAnB,EAA2C,CAA3C,EAA8CJ,IAA9C;AAFD,GAAP;AAID;AAED,OAAO,SAASK,aAAT,CAAuBC,KAAvB,EAA8BL,KAA9B,EAAqCC,IAArC,QAA2EK,KAA3E,EAAkF;AAAA,MAArCC,aAAqC,QAArCA,aAAqC;AAAA,MAAtBC,WAAsB,QAAtBA,WAAsB;AACvF,MAAIC,KAAK,GAAGf,KAAK,CAACgB,IAAN,CAAWV,KAAX,EAAkBC,IAAlB,EAAwB,KAAxB,CAAZ;AACA,MAAIU,KAAK,GAAGjB,KAAK,CAACkB,GAAN,CAAUlB,KAAK,CAACmB,OAAN,CAAcjB,GAAG,CAACS,KAAD,EAAQE,aAAR,CAAjB,EAAyC,KAAzC,CAAV,EAA2DP,KAA3D,CAAZ;AACA,MAAIc,GAAG,GAAGpB,KAAK,CAACqB,GAAN,CAAUrB,KAAK,CAACsB,IAAN,CAAWpB,GAAG,CAACS,KAAD,EAAQG,WAAR,CAAd,EAAoC,KAApC,CAAV,EAAsDP,IAAtD,CAAV;AAEA,MAAIgB,OAAO,GAAGxB,SAAS,CAACa,KAAD,EAAQ,UAAAY,CAAC;AAAA,WAAIxB,KAAK,CAACyB,EAAN,CAASD,CAAT,EAAYP,KAAZ,EAAmB,KAAnB,CAAJ;AAAA,GAAT,CAAvB;AACA,MAAIS,IAAI,GAAG1B,KAAK,CAACgB,IAAN,CAAWC,KAAX,EAAkBG,GAAlB,EAAuB,KAAvB,CAAX;AAEAM,EAAAA,IAAI,GAAGC,IAAI,CAACN,GAAL,CAASK,IAAT,EAAeX,KAAf,CAAP;AACAW,EAAAA,IAAI,GAAGC,IAAI,CAACT,GAAL,CAASQ,IAAT,EAAe,CAAf,CAAP;AAEA,SAAO;AACLf,IAAAA,KAAK,EAALA,KADK;AAELe,IAAAA,IAAI,EAAJA,IAFK;AAGLE,IAAAA,IAAI,EAAEL,OAAO,GAAG,CAHX;AAILM,IAAAA,KAAK,EAAEF,IAAI,CAACT,GAAL,CAASK,OAAO,GAAGG,IAAnB,EAAyB,CAAzB;AAJF,GAAP;AAMD;AAED,OAAO,SAASI,QAAT,CAAkBJ,IAAlB,EAAwBX,KAAxB,EAA8B;AACnC,MAAIgB,GAAG,GAAIL,IAAI,GAAGX,KAAR,GAAiB,GAAjB,GAAuB,GAAjC;AACA,SAAO;AAAEiB,IAAAA,eAAe,EAAED,GAAnB;AAAwBE,IAAAA,SAAS,EAAEF,GAAnC;AAAwCG,IAAAA,QAAQ,EAAEH,GAAlD,CAAwD;;AAAxD,GAAP;AACD;AAED,OAAO,SAASI,WAAT,CAAqBC,WAArB,EAAmD;AAAA,MAAjBC,KAAiB,uEAATC,QAAS;AACxD,MAAIC,CAAJ;AAAA,MAAOC,CAAP;AAAA,MAAUC,GAAV;AAAA,MACIC,MAAM,GAAG,EADb;AAAA,MAEIC,KAAK,GAAG,EAFZ;;AAIA,OAAKJ,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGH,WAAW,CAAC3B,MAA5B,EAAoC8B,CAAC,EAArC,EAAyC;AACvCE,IAAAA,GAAG,GAAGL,WAAW,CAACG,CAAD,CAAjB;;AAEA,SAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGE,MAAM,CAACjC,MAAvB,EAA+B+B,CAAC,EAAhC;AACE,UAAI,CAACI,WAAW,CAACH,GAAD,EAAMC,MAAM,CAACF,CAAD,CAAZ,CAAhB,EACE;AAFJ;;AAIA,QAAIA,CAAC,IAAIH,KAAT,EAAgB;AACdM,MAAAA,KAAK,CAACE,IAAN,CAAWJ,GAAX;AACD,KAFD,MAGK;AACH,OAACC,MAAM,CAACF,CAAD,CAAN,KAAcE,MAAM,CAACF,CAAD,CAAN,GAAY,EAA1B,CAAD,EAAgCK,IAAhC,CAAqCJ,GAArC;AACD;AACF;;AAED,OAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGG,MAAM,CAACjC,MAAvB,EAA+B8B,CAAC,EAAhC,EAAoC;AAClCG,IAAAA,MAAM,CAACH,CAAD,CAAN,CAAUO,IAAV,CAAe,UAACC,CAAD,EAAIC,CAAJ;AAAA,aAAUD,CAAC,CAACnB,IAAF,GAASoB,CAAC,CAACpB,IAArB;AAAA,KAAf,EADkC,CACS;AAC5C;;AAED,SAAO;AAAEc,IAAAA,MAAM,EAANA,MAAF;AAAUC,IAAAA,KAAK,EAALA;AAAV,GAAP;AACD;AAED,OAAO,SAASM,OAAT,CAAiBC,CAAjB,EAAoBjC,KAApB,EAA2BG,GAA3B,SAA+D;AAAA,MAA7BP,aAA6B,SAA7BA,aAA6B;AAAA,MAAdC,WAAc,SAAdA,WAAc;AACpE,MAAIqC,MAAM,GAAGnD,KAAK,CAACmB,OAAN,CAAcjB,GAAG,CAACgD,CAAD,EAAIrC,aAAJ,CAAjB,EAAqC,KAArC,CAAb;AACA,MAAIuC,IAAI,GAAGlD,GAAG,CAACgD,CAAD,EAAIpC,WAAJ,CAAd;AAEA,MAAIuC,eAAe,GAAGrD,KAAK,CAACsD,GAAN,CAAUH,MAAV,EAAkB/B,GAAlB,EAAuB,KAAvB,CAAtB;AACA,MAAImC,cAAc,GAAGvD,KAAK,CAACwD,GAAN,CAAUJ,IAAV,EAAgBnC,KAAhB,EAAuB,KAAvB,CAArB;AAEA,SAAOoC,eAAe,IAAIE,cAA1B;AACD;AAGD,OAAO,SAASX,WAAT,CAAqBH,GAArB,EAA0BgB,SAA1B,EAAqC;AAC1C,SAAOA,SAAS,CAACC,IAAV,CACL,UAAAC,QAAQ;AAAA,WAAIA,QAAQ,CAAC/B,IAAT,IAAiBa,GAAG,CAACZ,KAArB,IAA8B8B,QAAQ,CAAC9B,KAAT,IAAkBY,GAAG,CAACb,IAAxD;AAAA,GADH,CAAP;AAED;AAGD,OAAO,SAASgC,UAAT,CAAoBC,IAApB,EAA0BC,IAA1B,SAAgF;AAAA,MAA9CjD,aAA8C,SAA9CA,aAA8C;AAAA,MAA/BC,WAA+B,SAA/BA,WAA+B;AAAA,MAAlBiD,cAAkB,SAAlBA,cAAkB;AACrF,MAAIC,SAAS,GAAG,CAAChE,KAAK,CAACmB,OAAN,CAAcjB,GAAG,CAAC2D,IAAD,EAAOhD,aAAP,CAAjB,EAAwC,KAAxC,CAAD,GAAkD,CAACb,KAAK,CAACmB,OAAN,CAAcjB,GAAG,CAAC4D,IAAD,EAAOjD,aAAP,CAAjB,EAAwC,KAAxC,CAAnE;AAEA,MAAIoD,IAAI,GAAGjE,KAAK,CAACgB,IAAN,CACLd,GAAG,CAAC2D,IAAD,EAAOhD,aAAP,CADE,EAELb,KAAK,CAACsB,IAAN,CAAWpB,GAAG,CAAC2D,IAAD,EAAO/C,WAAP,CAAd,EAAmC,KAAnC,CAFK,EAGL,KAHK,CAAX;AAKA,MAAIoD,IAAI,GAAGlE,KAAK,CAACgB,IAAN,CACLd,GAAG,CAAC4D,IAAD,EAAOjD,aAAP,CADE,EAELb,KAAK,CAACsB,IAAN,CAAWpB,GAAG,CAAC4D,IAAD,EAAOhD,WAAP,CAAd,EAAmC,KAAnC,CAFK,EAGL,KAHK,CAAX;AAKA,SAAOkD,SAAS,CAAC;AAAD,KACXrC,IAAI,CAACT,GAAL,CAASgD,IAAT,EAAe,CAAf,IAAoBvC,IAAI,CAACT,GAAL,CAAS+C,IAAT,EAAe,CAAf,CADlB,CACoC;AADpC,KAEF,CAAC,CAAC/D,GAAG,CAAC4D,IAAD,EAAOC,cAAP,CAAL,GAA8B,CAAC,CAAC7D,GAAG,CAAC2D,IAAD,EAAOE,cAAP,CAFjC,CAEwD;AAFxD,KAGF,CAAC7D,GAAG,CAAC2D,IAAD,EAAOhD,aAAP,CAAJ,GAA4B,CAACX,GAAG,CAAC4D,IAAD,EAAOjD,aAAP,CAHrC,CAbqF,CAgBtB;AAChE","sourcesContent":["import findIndex from 'lodash/findIndex';\nimport dates from './dates';\nimport { accessor as get } from './accessors';\n\nexport function endOfRange(dateRange, unit = 'day') {\n  return {\n    first: dateRange[0],\n    last: dates.add(dateRange[dateRange.length - 1], 1, unit)\n  }\n}\n\nexport function eventSegments(event, first, last, { startAccessor, endAccessor }, range) {\n  let slots = dates.diff(first, last, 'day')\n  let start = dates.max(dates.startOf(get(event, startAccessor), 'day'), first);\n  let end = dates.min(dates.ceil(get(event, endAccessor), 'day'), last)\n\n  let padding = findIndex(range, x => dates.eq(x, start, 'day'));\n  let span = dates.diff(start, end, 'day');\n\n  span = Math.min(span, slots)\n  span = Math.max(span, 1);\n\n  return {\n    event,\n    span,\n    left: padding + 1,\n    right: Math.max(padding + span, 1)\n  }\n}\n\nexport function segStyle(span, slots){\n  let per = (span / slots) * 100 + '%';\n  return { WebkitFlexBasis: per, flexBasis: per, maxWidth: per } // IE10/11 need max-width. flex-basis doesn't respect box-sizing\n}\n\nexport function eventLevels(rowSegments, limit = Infinity){\n  let i, j, seg\n    , levels = []\n    , extra = [];\n\n  for (i = 0; i < rowSegments.length; i++) {\n    seg = rowSegments[i];\n\n    for (j = 0; j < levels.length; j++)\n      if (!segsOverlap(seg, levels[j]))\n        break\n\n    if (j >= limit) {\n      extra.push(seg)\n    }\n    else {\n      (levels[j] || (levels[j] = [])).push(seg);\n    }\n  }\n\n  for (i = 0; i < levels.length; i++) {\n    levels[i].sort((a, b) => a.left - b.left); //eslint-disable-line\n  }\n\n  return { levels, extra };\n}\n\nexport function inRange(e, start, end, { startAccessor, endAccessor }){\n  let eStart = dates.startOf(get(e, startAccessor), 'day')\n  let eEnd = get(e, endAccessor)\n\n  let startsBeforeEnd = dates.lte(eStart, end, 'day')\n  let endsAfterStart = dates.gte(eEnd, start, 'day')\n\n  return startsBeforeEnd && endsAfterStart\n}\n\n\nexport function segsOverlap(seg, otherSegs) {\n  return otherSegs.some(\n    otherSeg => otherSeg.left <= seg.right && otherSeg.right >= seg.left)\n}\n\n\nexport function sortEvents(evtA, evtB, { startAccessor, endAccessor, allDayAccessor }) {\n  let startSort = +dates.startOf(get(evtA, startAccessor), 'day') - +dates.startOf(get(evtB, startAccessor), 'day')\n\n  let durA = dates.diff(\n        get(evtA, startAccessor)\n      , dates.ceil(get(evtA, endAccessor), 'day')\n      , 'day');\n\n  let durB = dates.diff(\n        get(evtB, startAccessor)\n      , dates.ceil(get(evtB, endAccessor), 'day')\n      , 'day');\n\n  return startSort // sort by start Day first\n    || Math.max(durB, 1) - Math.max(durA, 1) // events spanning multiple days go first\n    || !!get(evtB, allDayAccessor) - !!get(evtA, allDayAccessor) // then allDay single day events\n    || +get(evtA, startAccessor) - +get(evtB, startAccessor)     // then sort by start time\n}\n"]},"metadata":{},"sourceType":"module"}