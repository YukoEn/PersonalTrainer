{"ast":null,"code":"import _toConsumableArray from \"/Users/yukoenqvist/personaltrainer/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { accessor as get } from './accessors';\nimport dates from './dates';\nexport function startsBefore(date, min) {\n  return dates.lt(dates.merge(min, date), min, 'minutes');\n}\nexport function positionFromDate(date, min, total) {\n  if (startsBefore(date, min)) return 0;\n  var diff = dates.diff(min, dates.merge(min, date), 'minutes');\n  return Math.min(diff, total);\n}\n/**\n * Events will be sorted primarily according to earliest start time.\n * If two events start at the same time, the one with the longest duration will\n * be placed first.\n */\n\nvar sort = function sort(events, _ref) {\n  var startAccessor = _ref.startAccessor,\n      endAccessor = _ref.endAccessor;\n  return events.sort(function (a, b) {\n    var startA = +get(a, startAccessor);\n    var startB = +get(b, startAccessor);\n\n    if (startA === startB) {\n      return +get(b, endAccessor) - +get(a, endAccessor);\n    }\n\n    return startA - startB;\n  });\n};\n\nvar getSlot = function getSlot(event, accessor, min, totalMin) {\n  return event && positionFromDate(get(event, accessor), min, totalMin);\n};\n/**\n * Two events are considered siblings if the difference between their\n * start time is less than (step*timeslots) hour.\n */\n\n\nvar isSibling = function isSibling(idx1, idx2, _ref2) {\n  var events = _ref2.events,\n      startAccessor = _ref2.startAccessor,\n      endAccessor = _ref2.endAccessor,\n      min = _ref2.min,\n      totalMin = _ref2.totalMin,\n      step = _ref2.step,\n      timeslots = _ref2.timeslots;\n  var event1 = events[idx1];\n  var event2 = events[idx2];\n  if (!event1 || !event2) return false;\n  var start1 = getSlot(event1, startAccessor, min, totalMin);\n  var start2 = getSlot(event2, startAccessor, min, totalMin);\n  var end1 = getSlot(event1, endAccessor, min, totalMin);\n  return Math.abs(start1 - start2) < step * timeslots && start2 < end1;\n};\n/**\n * An event is considered a child of another event if its start time is\n * more than (step*timeslots) hour later than the other event's start time,\n * but before its end time.\n */\n\n\nvar isChild = function isChild(parentIdx, childIdx, _ref3) {\n  var events = _ref3.events,\n      startAccessor = _ref3.startAccessor,\n      endAccessor = _ref3.endAccessor,\n      min = _ref3.min,\n      totalMin = _ref3.totalMin,\n      step = _ref3.step,\n      timeslots = _ref3.timeslots;\n  if (isSibling(parentIdx, childIdx, {\n    events: events,\n    startAccessor: startAccessor,\n    endAccessor: endAccessor,\n    min: min,\n    totalMin: totalMin,\n    step: step,\n    timeslots: timeslots\n  })) return false;\n  var parentEnd = getSlot(events[parentIdx], endAccessor, min, totalMin);\n  var childStart = getSlot(events[childIdx], startAccessor, min, totalMin);\n  return parentEnd > childStart;\n};\n/**\n * Given an event index, siblings directly following it will be found and\n * returned as an array of indexes.\n */\n\n\nvar getSiblings = function getSiblings(idx, _ref4) {\n  var events = _ref4.events,\n      startAccessor = _ref4.startAccessor,\n      endAccessor = _ref4.endAccessor,\n      min = _ref4.min,\n      totalMin = _ref4.totalMin,\n      step = _ref4.step,\n      timeslots = _ref4.timeslots;\n  var nextIdx = idx;\n  var siblings = [];\n\n  while (isSibling(idx, ++nextIdx, {\n    events: events,\n    startAccessor: startAccessor,\n    endAccessor: endAccessor,\n    min: min,\n    totalMin: totalMin,\n    step: step,\n    timeslots: timeslots\n  })) {\n    siblings.push(nextIdx);\n  }\n\n  return siblings;\n};\n/**\n * Given an event index, and a start search position, all child events to that\n * event will be found and placed into groups of siblings.\n * The return value is an array of child group arrays, as well as the largest\n * size of the child groups.\n */\n\n\nvar getChildGroups = function getChildGroups(idx, nextIdx, _ref5) {\n  var events = _ref5.events,\n      startAccessor = _ref5.startAccessor,\n      endAccessor = _ref5.endAccessor,\n      min = _ref5.min,\n      totalMin = _ref5.totalMin,\n      step = _ref5.step,\n      timeslots = _ref5.timeslots;\n  var groups = [];\n  var nbrOfColumns = 0;\n\n  while (isChild(idx, nextIdx, {\n    events: events,\n    startAccessor: startAccessor,\n    endAccessor: endAccessor,\n    min: min,\n    totalMin: totalMin,\n    step: step,\n    timeslots: timeslots\n  })) {\n    var childGroup = [nextIdx];\n    var siblingIdx = nextIdx;\n\n    while (isSibling(nextIdx, ++siblingIdx, {\n      events: events,\n      startAccessor: startAccessor,\n      endAccessor: endAccessor,\n      min: min,\n      totalMin: totalMin,\n      step: step,\n      timeslots: timeslots\n    })) {\n      childGroup.push(siblingIdx);\n    }\n\n    nbrOfColumns = Math.max(nbrOfColumns, childGroup.length);\n    groups.push(childGroup);\n    nextIdx = siblingIdx;\n  }\n\n  return {\n    childGroups: groups,\n    nbrOfChildColumns: nbrOfColumns\n  };\n};\n\nvar constructEvent = function constructEvent(title, start, end) {\n  return {\n    title: title,\n    start: start,\n    end: end\n  };\n};\n\nvar handleMultiDayEvents = function handleMultiDayEvents(title, start, end, current) {\n  var s = new Date(start);\n  var e = new Date(end);\n  var c = new Date(current); // use noon to compare dates to avoid DST issues\n\n  s.setHours(12, 0, 0, 0);\n  e.setHours(12, 0, 0, 0);\n  c.setHours(12, 0, 0, 0); // if current day is at the start, but spans multiple days, correct the end\n\n  if (+c === +s && c < e) {\n    return constructEvent(title, start, dates.endOf(start, 'day'));\n  } // if current day is in between start and end dates, span all day\n  else if (c > s && c < e) {\n      return constructEvent(title, current, dates.endOf(current, 'day'));\n    } // if current day is at the end of a multi day event, start at midnight to the end\n    else if (c > s && +c === +e) {\n        return constructEvent(title, current, end);\n      }\n};\n/**\n * Returns height and top offset, both in percentage, for an event at\n * the specified index.\n */\n\n\nvar getYStyles = function getYStyles(idx, _ref6) {\n  var events = _ref6.events,\n      startAccessor = _ref6.startAccessor,\n      endAccessor = _ref6.endAccessor,\n      min = _ref6.min,\n      showMultiDayTimes = _ref6.showMultiDayTimes,\n      totalMin = _ref6.totalMin,\n      step = _ref6.step;\n  var event = events[idx];\n  var startDate = get(event, startAccessor); // start date\n\n  var endDate = get(event, endAccessor); // end date\n\n  var currentDate = new Date(min); // min is the current date at midnight\n\n  var multiDayEvent;\n\n  if (showMultiDayTimes) {\n    multiDayEvent = handleMultiDayEvents(event.title, startDate, endDate, currentDate);\n  }\n\n  var start = getSlot(multiDayEvent || event, startAccessor, min, totalMin);\n  var end = Math.max(getSlot(multiDayEvent || event, endAccessor, min, totalMin), start + step);\n  var top = start / totalMin * 100;\n  var bottom = end / totalMin * 100;\n  var height = bottom - top;\n  return {\n    top: top,\n    height: height\n  };\n};\n/**\n * Takes an array of unsorted events, and returns a sorted array\n * containing the same events, but with an additional style property.\n * These styles will position the events similarly to Google Calendar.\n *\n * The algorithm will start by sorting the array, and then iterating over it.\n * Starting at the first event, each of its siblings and children, placed in\n * groups of siblings, will be found. Both are needed in order to calculate the\n * width of the first event. When the width is known, its siblings will be\n * given the same width, but with an incremental x-offset.\n *\n * Each group of children will be looking to move as far away from its original\n * parent as possible. A move can be made to one of the parent's siblings, if\n * that sibling is also a parent to the child group. This will make room for\n * more events.\n *\n * When a child group knows its parent, it looks at the space occupied by that\n * parent, and calculates the remaning available space and divides that among\n * each other.\n *\n * All widths and x-offsets are calculated without taking overlapping into\n * account. Overlapping is added in the end according to the OVERLAP_MULTIPLIER.\n * If that is set to 0, the events won't overlap or grow.\n *\n * When one of these rounds are finished, all events connected have been\n * traversed, so the cursor will be moved past all of them.\n */\n\n\nexport default function getStyledEvents(_ref7) {\n  var unsortedEvents = _ref7.events,\n      startAccessor = _ref7.startAccessor,\n      endAccessor = _ref7.endAccessor,\n      min = _ref7.min,\n      totalMin = _ref7.totalMin,\n      showMultiDayTimes = _ref7.showMultiDayTimes,\n      step = _ref7.step,\n      timeslots = _ref7.timeslots;\n  var OVERLAP_MULTIPLIER = 0.3;\n  var events = sort(unsortedEvents, {\n    startAccessor: startAccessor,\n    endAccessor: endAccessor\n  });\n  var helperArgs = {\n    events: events,\n    startAccessor: startAccessor,\n    endAccessor: endAccessor,\n    min: min,\n    showMultiDayTimes: showMultiDayTimes,\n    totalMin: totalMin,\n    step: step,\n    timeslots: timeslots\n  };\n  var styledEvents = [];\n  var idx = 0; // One iteration will cover all connected events.\n\n  var _loop = function _loop() {\n    var siblings = getSiblings(idx, helperArgs);\n\n    var _getChildGroups = getChildGroups(idx, idx + siblings.length + 1, helperArgs),\n        childGroups = _getChildGroups.childGroups,\n        nbrOfChildColumns = _getChildGroups.nbrOfChildColumns;\n\n    var nbrOfColumns = Math.max(nbrOfChildColumns, siblings.length) + 1; // Set styles to top level events.\n\n    [idx].concat(_toConsumableArray(siblings)).forEach(function (eventIdx, siblingIdx) {\n      var width = 100 / nbrOfColumns;\n      var xAdjustment = width * (nbrOfColumns > 1 ? OVERLAP_MULTIPLIER : 0);\n\n      var _getYStyles = getYStyles(eventIdx, helperArgs),\n          top = _getYStyles.top,\n          height = _getYStyles.height;\n\n      styledEvents[eventIdx] = {\n        event: events[eventIdx],\n        style: {\n          top: top,\n          height: height,\n          width: width + xAdjustment,\n          xOffset: width * siblingIdx - xAdjustment\n        }\n      };\n    });\n    childGroups.forEach(function (group) {\n      var parentIdx = idx;\n      var siblingIdx = 0; // Move child group to sibling if possible, since this will makes\n      // room for more events.\n\n      while (isChild(siblings[siblingIdx], group[0], helperArgs)) {\n        parentIdx = siblings[siblingIdx];\n        siblingIdx++;\n      } // Set styles to child events.\n\n\n      group.forEach(function (eventIdx, i) {\n        var parentStyle = styledEvents[parentIdx].style;\n        var spaceOccupiedByParent = parentStyle.width + parentStyle.xOffset;\n        var columns = Math.min(group.length, nbrOfColumns);\n        var width = (100 - spaceOccupiedByParent) / columns;\n        var xAdjustment = spaceOccupiedByParent * OVERLAP_MULTIPLIER;\n\n        var _getYStyles2 = getYStyles(eventIdx, helperArgs),\n            top = _getYStyles2.top,\n            height = _getYStyles2.height;\n\n        styledEvents[eventIdx] = {\n          event: events[eventIdx],\n          style: {\n            top: top,\n            height: height,\n            width: width + xAdjustment,\n            xOffset: spaceOccupiedByParent + width * i - xAdjustment\n          }\n        };\n      });\n    }); // Move past all events we just went through\n\n    idx += 1 + siblings.length + childGroups.reduce(function (total, group) {\n      return total + group.length;\n    }, 0);\n  };\n\n  while (idx < events.length) {\n    _loop();\n  }\n\n  return styledEvents;\n}","map":{"version":3,"sources":["/Users/yukoenqvist/personaltrainer/src/utils/dayViewLayout.js"],"names":["accessor","get","dates","startsBefore","date","min","lt","merge","positionFromDate","total","diff","Math","sort","events","startAccessor","endAccessor","a","b","startA","startB","getSlot","event","totalMin","isSibling","idx1","idx2","step","timeslots","event1","event2","start1","start2","end1","abs","isChild","parentIdx","childIdx","parentEnd","childStart","getSiblings","idx","nextIdx","siblings","push","getChildGroups","groups","nbrOfColumns","childGroup","siblingIdx","max","length","childGroups","nbrOfChildColumns","constructEvent","title","start","end","handleMultiDayEvents","current","s","Date","e","c","setHours","endOf","getYStyles","showMultiDayTimes","startDate","endDate","currentDate","multiDayEvent","top","bottom","height","getStyledEvents","unsortedEvents","OVERLAP_MULTIPLIER","helperArgs","styledEvents","forEach","eventIdx","width","xAdjustment","style","xOffset","group","i","parentStyle","spaceOccupiedByParent","columns","reduce"],"mappings":"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","sourcesContent":["import { accessor as get } from './accessors'\nimport dates from './dates'\n\nexport function startsBefore(date, min) {\n  return dates.lt(dates.merge(min, date), min, 'minutes')\n}\n\nexport function positionFromDate(date, min, total) {\n  if (startsBefore(date, min))\n    return 0\n\n  let diff = dates.diff(min, dates.merge(min, date), 'minutes')\n  return Math.min(diff, total)\n}\n\n/**\n * Events will be sorted primarily according to earliest start time.\n * If two events start at the same time, the one with the longest duration will\n * be placed first.\n */\nlet sort = (events, { startAccessor, endAccessor }) => events.sort((a, b) => {\n  let startA = +get(a, startAccessor)\n  let startB = +get(b, startAccessor)\n\n  if (startA === startB) {\n    return +get(b, endAccessor) - +get(a, endAccessor)\n  }\n\n  return startA - startB\n})\n\nlet getSlot = (event, accessor, min, totalMin) => event && positionFromDate(\n  get(event, accessor), min, totalMin\n)\n\n/**\n * Two events are considered siblings if the difference between their\n * start time is less than (step*timeslots) hour.\n */\nlet isSibling = (idx1, idx2, { events, startAccessor, endAccessor, min, totalMin, step, timeslots }) => {\n  let event1 = events[idx1]\n  let event2 = events[idx2]\n\n  if (!event1 || !event2) return false\n\n  let start1 = getSlot(event1, startAccessor, min, totalMin)\n  let start2 = getSlot(event2, startAccessor, min, totalMin)\n  let end1 = getSlot(event1, endAccessor, min, totalMin)\n\n  return (Math.abs(start1 - start2) < (step * timeslots) && start2 < end1)\n}\n\n/**\n * An event is considered a child of another event if its start time is\n * more than (step*timeslots) hour later than the other event's start time,\n * but before its end time.\n */\nlet isChild = (parentIdx, childIdx, {\n  events, startAccessor, endAccessor, min, totalMin, step, timeslots\n}) => {\n  if (isSibling(\n    parentIdx, childIdx,\n    { events, startAccessor, endAccessor, min, totalMin, step, timeslots }\n  )) return false\n\n  let parentEnd = getSlot(events[parentIdx], endAccessor, min, totalMin)\n  let childStart = getSlot(events[childIdx], startAccessor, min, totalMin)\n\n  return parentEnd > childStart\n}\n\n/**\n * Given an event index, siblings directly following it will be found and\n * returned as an array of indexes.\n */\nlet getSiblings = (idx, {\n  events, startAccessor, endAccessor, min, totalMin, step, timeslots\n}) => {\n  let nextIdx = idx\n  let siblings = []\n\n  while (isSibling(\n    idx, ++nextIdx, { events, startAccessor, endAccessor, min, totalMin, step, timeslots })\n  ) {\n    siblings.push(nextIdx)\n  }\n\n  return siblings\n}\n\n/**\n * Given an event index, and a start search position, all child events to that\n * event will be found and placed into groups of siblings.\n * The return value is an array of child group arrays, as well as the largest\n * size of the child groups.\n */\nlet getChildGroups = (idx, nextIdx, {\n  events, startAccessor, endAccessor, min, totalMin, step, timeslots\n}) => {\n  let groups = []\n  let nbrOfColumns = 0\n\n  while (isChild(\n    idx, nextIdx,\n    { events, startAccessor, endAccessor, min, totalMin, step, timeslots }\n  )) {\n    let childGroup = [nextIdx]\n    let siblingIdx = nextIdx\n\n    while (isSibling(\n      nextIdx, ++siblingIdx,\n      { events, startAccessor, endAccessor, min, totalMin, step, timeslots }\n    )) {\n      childGroup.push(siblingIdx)\n    }\n\n    nbrOfColumns = Math.max(nbrOfColumns, childGroup.length)\n    groups.push(childGroup)\n    nextIdx = siblingIdx\n  }\n\n  return { childGroups: groups, nbrOfChildColumns: nbrOfColumns }\n}\n\nlet constructEvent = (title, start, end) => {\n  return {\n    title: title,\n    start: start,\n    end: end\n  }\n}\n\nlet handleMultiDayEvents = (title, start, end, current) => {\n  let s = new Date(start)\n  let e = new Date(end)\n  let c = new Date(current)\n\n  // use noon to compare dates to avoid DST issues\n  s.setHours(12, 0, 0, 0)\n  e.setHours(12, 0, 0, 0)\n  c.setHours(12, 0, 0, 0)\n\n  // if current day is at the start, but spans multiple days, correct the end\n  if (+c === +s && c < e) {\n    return constructEvent(title, start, dates.endOf(start, 'day'))\n  }\n\n  // if current day is in between start and end dates, span all day\n  else if (c > s && c < e) {\n    return constructEvent(title, current, dates.endOf(current, 'day'))\n  }\n\n  // if current day is at the end of a multi day event, start at midnight to the end\n  else if (c > s && +c === +e) {\n    return constructEvent(title, current, end)\n  }\n}\n\n/**\n * Returns height and top offset, both in percentage, for an event at\n * the specified index.\n */\nlet getYStyles = (idx, {\n  events, startAccessor, endAccessor, min, showMultiDayTimes, totalMin, step\n}) => {\n  let event = events[idx]\n\n  let startDate = get(event, startAccessor) // start date\n  let endDate = get(event, endAccessor) // end date\n  let currentDate = new Date(min) // min is the current date at midnight\n\n  let multiDayEvent\n  if (showMultiDayTimes) {\n    multiDayEvent = handleMultiDayEvents(event.title, startDate, endDate, currentDate)\n  }\n\n  let start = getSlot(multiDayEvent || event, startAccessor, min, totalMin)\n  let end = Math.max(getSlot(multiDayEvent || event, endAccessor, min, totalMin), start + step)\n  let top = start / totalMin * 100\n  let bottom = end / totalMin * 100\n\n  let height = bottom - top\n\n  return {\n    top,\n    height\n  }\n}\n\n/**\n * Takes an array of unsorted events, and returns a sorted array\n * containing the same events, but with an additional style property.\n * These styles will position the events similarly to Google Calendar.\n *\n * The algorithm will start by sorting the array, and then iterating over it.\n * Starting at the first event, each of its siblings and children, placed in\n * groups of siblings, will be found. Both are needed in order to calculate the\n * width of the first event. When the width is known, its siblings will be\n * given the same width, but with an incremental x-offset.\n *\n * Each group of children will be looking to move as far away from its original\n * parent as possible. A move can be made to one of the parent's siblings, if\n * that sibling is also a parent to the child group. This will make room for\n * more events.\n *\n * When a child group knows its parent, it looks at the space occupied by that\n * parent, and calculates the remaning available space and divides that among\n * each other.\n *\n * All widths and x-offsets are calculated without taking overlapping into\n * account. Overlapping is added in the end according to the OVERLAP_MULTIPLIER.\n * If that is set to 0, the events won't overlap or grow.\n *\n * When one of these rounds are finished, all events connected have been\n * traversed, so the cursor will be moved past all of them.\n */\nexport default function getStyledEvents ({\n  events: unsortedEvents, startAccessor, endAccessor, min, totalMin, showMultiDayTimes,\n  step, timeslots\n}) {\n  let OVERLAP_MULTIPLIER = 0.3\n  let events = sort(unsortedEvents, { startAccessor, endAccessor })\n  let helperArgs = { events, startAccessor, endAccessor, min, showMultiDayTimes, totalMin, step, timeslots }\n  let styledEvents = []\n  let idx = 0\n\n  // One iteration will cover all connected events.\n  while (idx < events.length) {\n    let siblings = getSiblings(idx, helperArgs)\n    let { childGroups, nbrOfChildColumns } = getChildGroups(\n      idx, idx + siblings.length + 1, helperArgs\n    )\n    let nbrOfColumns = Math.max(nbrOfChildColumns, siblings.length) + 1;\n\n    // Set styles to top level events.\n    [idx, ...siblings].forEach((eventIdx, siblingIdx) => {\n      let width = 100 / nbrOfColumns\n      let xAdjustment = width * (nbrOfColumns > 1 ? OVERLAP_MULTIPLIER : 0)\n      let { top, height } = getYStyles(eventIdx, helperArgs)\n\n      styledEvents[eventIdx] = {\n        event: events[eventIdx],\n        style: {\n          top,\n          height,\n          width: width + xAdjustment,\n          xOffset: (width * siblingIdx) - xAdjustment\n        }\n      }\n    })\n\n    childGroups.forEach(group => {\n      let parentIdx = idx\n      let siblingIdx = 0\n\n      // Move child group to sibling if possible, since this will makes\n      // room for more events.\n      while (isChild(siblings[siblingIdx], group[0], helperArgs)) {\n        parentIdx = siblings[siblingIdx]\n        siblingIdx++\n      }\n\n      // Set styles to child events.\n      group.forEach((eventIdx, i) => {\n        let { style: parentStyle } = styledEvents[parentIdx]\n        let spaceOccupiedByParent = parentStyle.width + parentStyle.xOffset\n        let columns = Math.min(group.length, nbrOfColumns)\n        let width = (100 - spaceOccupiedByParent) / columns\n        let xAdjustment = spaceOccupiedByParent * OVERLAP_MULTIPLIER\n        let { top, height } = getYStyles(eventIdx, helperArgs)\n\n        styledEvents[eventIdx] = {\n          event: events[eventIdx],\n          style: {\n            top,\n            height,\n            width: width + xAdjustment,\n            xOffset: spaceOccupiedByParent + (width * i) - xAdjustment\n          }\n        }\n      })\n    })\n\n    // Move past all events we just went through\n    idx += 1 + siblings.length + childGroups.reduce(\n      (total, group) => total + group.length, 0\n    )\n  }\n\n  return styledEvents\n}\n"]},"metadata":{},"sourceType":"module"}